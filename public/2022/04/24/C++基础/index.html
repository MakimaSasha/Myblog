<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C++ 面向对象 | Makima</title><meta name="author" content="MaQiang"><meta name="copyright" content="MaQiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本概念_1——杂项篇1234一个类应该要有的函数：	default constructor &#x2F;&#x2F;默认构造函数	virtual destructor	&#x2F;&#x2F;带virtual关键字的析构函数	copy constructor	&#x2F;&#x2F;拷贝构造函数    What to do not How to do123456	Class 类，指具有相似特点的东西的抽象集合，类是虚的，是一种观点，像是对象的说明	Obj">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 面向对象">
<meta property="og:url" content="http://mq.cq.cn/2022/04/24/C++%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Makima">
<meta property="og:description" content="基本概念_1——杂项篇1234一个类应该要有的函数：	default constructor &#x2F;&#x2F;默认构造函数	virtual destructor	&#x2F;&#x2F;带virtual关键字的析构函数	copy constructor	&#x2F;&#x2F;拷贝构造函数    What to do not How to do123456	Class 类，指具有相似特点的东西的抽象集合，类是虚的，是一种观点，像是对象的说明	Obj">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/02/24/zT4VKe6ECMLfghY.jpg">
<meta property="article:published_time" content="2022-04-24T02:29:36.000Z">
<meta property="article:modified_time" content="2023-02-23T14:53:29.966Z">
<meta property="article:author" content="MaQiang">
<meta property="article:tag" content="计算机语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/24/zT4VKe6ECMLfghY.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/02/24/sTzSX9UNJYpbZFq.png"><link rel="canonical" href="http://mq.cq.cn/2022/04/24/C++%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 面向对象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-23 22:53:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/02/24/zT4VKe6ECMLfghY.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog-info"><a href="/" title="Makima"><span class="site-name">Makima</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ 面向对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-24T02:29:36.000Z" title="发表于 2022-04-24 10:29:36">2022-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-23T14:53:29.966Z" title="更新于 2023-02-23 22:53:29">2023-02-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 面向对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基本概念-1——杂项篇"><a href="#基本概念-1——杂项篇" class="headerlink" title="基本概念_1——杂项篇"></a>基本概念_1——杂项篇</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个类应该要有的函数：</span><br><span class="line"><span class="code">	default constructor //默认构造函数</span></span><br><span class="line"><span class="code">	virtual destructor	//带virtual关键字的析构函数</span></span><br><span class="line"><span class="code">	copy constructor	//拷贝构造函数</span></span><br></pre></td></tr></table></figure>



<h4 id="What-to-do-not-How-to-do"><a href="#What-to-do-not-How-to-do" class="headerlink" title="What to do not How to do"></a>What to do not How to do</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	Class 类，指具有相似特点的东西的抽象集合，类是虚的，是一种观点，像是对象的说明</span></span><br><span class="line"><span class="code">	Object 实体，对象，是实例化的Class，是实的</span></span><br><span class="line"><span class="code">	Interface 接口，即对象接收外部消息的途径，方法。主要是为了低耦合，隐藏内部实现</span></span><br><span class="line"><span class="code">注：Interface也可以理解成一个类对外公开的部分，可以是成员函数，也可以是成员变量</span></span><br><span class="line"><span class="code">	Encapsulation 封装，把数据和对数据的操作放在对象里，隐藏数据的细节，其他对象只能通过受允许的操作来操作数据</span></span><br><span class="line"><span class="code">	:: 域名解析符，用法&lt;Class Name&gt;::&lt;function name&gt;   不加Class Name时意味着为全局函数，同理 ::a++，意味着全局变量a++</span></span><br></pre></td></tr></table></figure>

<h4 id="一些基本常识："><a href="#一些基本常识：" class="headerlink" title="一些基本常识："></a>一些基本常识：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	&#123;</span></span><br><span class="line"><span class="code">		code;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">可以使用大括号来把一些代码括起来，其中的变量仅在大括号中存在，离开大括号就会自动销毁</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	# 开头的代码是编译预处理指令 如：#ifndef xxx 如果没有定义xxx #define xxx就定义xxx  #endif 定义结束</span></span><br><span class="line"><span class="code">	注：#ifndef 常用于可能会出现反复定义的情况时 如：a.h中include了b.h，b.h中include了a.h，导致a.h中的定义出现不止一次</span></span><br><span class="line"><span class="code">因此引入了标准头文件结构避免出现重复定义：</span></span><br><span class="line"><span class="code">	#ifndef HEADER_FLAG</span></span><br><span class="line"><span class="code">	#define HEADER_FLAG</span></span><br><span class="line"><span class="code">	//code</span></span><br><span class="line"><span class="code">	#endif</span></span><br><span class="line"><span class="code">	一个头文件只放一个Class的声明（Class大概是只有声明）</span></span><br><span class="line"><span class="code">	&quot;xxx.h&quot;	用&quot;&quot;括起来的头文件，编译器会去当前目录查找 </span></span><br><span class="line"><span class="code">	&lt;xxx.h&gt;	用&lt;&gt;括起来的头文件，编译器会去系统目录查找</span></span><br><span class="line"><span class="code">	&lt;xxx&gt;	c++特有的插入方法</span></span><br><span class="line"><span class="code">	*.h	文件中放声明（只有头没有body）declaration  **全局变量的declaration用关键字 extern &lt;var type&gt; &lt;var name&gt;**</span></span><br><span class="line"><span class="code">该方式等价于对编译器说，我知道有一个全局变量，叫什么，什么类型，但我不知道它在哪里，然后编译器就会给它留个位置</span></span><br><span class="line"><span class="code">	头文件 Header == interface</span></span><br><span class="line"><span class="code">	*.cpp 文件中放定义（有头有body，实现）  definition，一个.cpp文件就是一个编译单元，在编译环节，编译器只会关注这一个编译单元，所以就是存在和其他编译单元同名的全局变量也是能通过编译的</span></span><br><span class="line"><span class="code">	Abstract 抽象，只看某个层次，屏蔽其他部分的做法就叫抽象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般来说a.h文件是用来给调用a.cpp文件中的实现的其他文件看的，a.cpp文件是用来实现的。但也有特例，如内联函数的定义就需要直接写在.h文件中</span><br></pre></td></tr></table></figure>

<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><a href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">内联函数</a></h3><h4 id="编译过程："><a href="#编译过程：" class="headerlink" title="编译过程："></a>编译过程：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	b(编译预处理) --&gt; c[编译]</span><br><span class="line">	c --&gt; d[汇编]</span><br><span class="line">	d --&gt; e(链接)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	a(.ii)--&gt;b[.o]</span><br><span class="line">	b--&gt;c[.s]</span><br><span class="line">	c--&gt;d(.out)</span><br><span class="line">	c--&gt;e(.exe)</span><br></pre></td></tr></table></figure>

<h4 id="g-命令"><a href="#g-命令" class="headerlink" title="g++命令"></a>g++命令</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--save-temps  保留中间文件</span><br><span class="line">-Wall  输出所有可能的warning</span><br><span class="line">-c 只编译不链接</span><br></pre></td></tr></table></figure>



<h2 id="基本概念-2——变量篇"><a href="#基本概念-2——变量篇" class="headerlink" title="基本概念_2——变量篇"></a>基本概念_2——变量篇</h2><h4 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    local variable 本地变量，函数中定义的变量</span></span><br><span class="line"><span class="code">    parameters	函数参数</span></span><br><span class="line"><span class="code">两种variable都是一样的，仅在对应函数运行时存在，放在本地</span></span><br></pre></td></tr></table></figure>

<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a><strong>重点</strong></h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field （一般）成员变量，类中的变量。存在于对应实例化的对象中，如，a，b都为A类的对象，则a中的成员变量值与b中可以不同</span><br></pre></td></tr></table></figure>

<p>[参看检验代码_1 ](#分析类不同实例的成员变量值			&#x3D;&#x3D;检验代码_1&#x3D;&#x3D;)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：c++对象中实际仅有成员变量，也就是说，A a，实际a指向的地址中只有a的成员变量，没有成员函数在里面</span><br></pre></td></tr></table></figure>

<p>[参考检验代码_2](#探究c++对象实质			&#x3D;&#x3D;检验代码_2&#x3D;&#x3D;)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	field_function 成员函数，类的函数，属于类，不属于任何某个对象（实例）,相当于是该类所有对象的公共函数，但它（成员函数）会知道自己本次控制的是哪一个对象的成员变量</span></span><br><span class="line"><span class="code">注：实际就是采用了  this 是一个hidden parameter this的类型就是成员函数所属的类的指针，也就是说，所有的成员变量系统实际上是默认在其前面加上了this-&gt;，当然主动加上也是可以的</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	对于成员变量和成员函数可以这样理解，动物会运动，运动就是一种动物类的成员函数，如鸟会飞，飞这个动作不是属于某个鸟的，而是鸟这类的。但每一个动物的大小，颜色属于成员变量，如某只鸟的颜色，大小，</span></span><br></pre></td></tr></table></figure>



<h2 id="基本概念-3——构造析构篇"><a href="#基本概念-3——构造析构篇" class="headerlink" title="基本概念_3——构造析构篇"></a>基本概念_3——构造析构篇</h2><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor 构造，构造函数。无返回类型和返回值，且与类同名。在对象实例化时自动调用（无法干预），也在此时传参数给构造函数。其他同成员函数</span><br></pre></td></tr></table></figure>

<h5 id="例子-如："><a href="#例子-如：" class="headerlink" title="例子 如："></a>例子 如：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Tree</span>(<span class="type">int</span> x);	<span class="comment">//类Tree的构造函数，这里的形参名必须和构造函数定义处的形参一致	</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Tree::<span class="built_in">Tree</span>(<span class="type">int</span> x)&#123;		<span class="comment">//实现一些初始化的操作，实例化对象时调用</span></span><br><span class="line">    i = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destructor 析构，析构函数。无返回类型，且与类同名，但前面多一个tilde ~符号。在对象要被结束掉时调用，无参数。析构意味着该对象的空间即将被收回，此时调用析构函数。</span><br></pre></td></tr></table></figure>

<h5 id="例子-如：-1"><a href="#例子-如：-1" class="headerlink" title="例子 如："></a>例子 如：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="type">int</span> init);</span><br><span class="line">    ~<span class="built_in">Cat</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat::<span class="built_in">Cat</span>(<span class="type">int</span> init)&#123; <span class="comment">//构造函数</span></span><br><span class="line">    i = init;</span><br><span class="line">&#125;</span><br><span class="line">Cat::~<span class="built_in">Cat</span>()&#123;		<span class="comment">//析构函数，一般执行释放系统资源等操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Game Over&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	cout &lt;&lt; <span class="string">&quot;before create &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="function">Cat <span class="title">cat</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	&#125;   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after destructure&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基础概念-4——对象初始化-amp-amp-new和delete"><a href="#基础概念-4——对象初始化-amp-amp-new和delete" class="headerlink" title="基础概念_4——对象初始化 &amp;&amp; new和delete"></a>基础概念_4——对象初始化 &amp;&amp; new和delete</h2><h4 id="常识："><a href="#常识：" class="headerlink" title="常识："></a>常识：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++中的struct和class基本是一样，都可以称为类，只是struct在没有声明访问属性的地方默认为public，而class默认为private。一般只有当类非常简单时用struct，其他情况都用class</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">X x1 = &#123;<span class="number">1</span>, <span class="number">1.1</span>, <span class="string">&#x27;c&#x27;</span>&#125;;	<span class="comment">//结构体初始化的一种方式</span></span><br></pre></td></tr></table></figure>

<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	default constructor 	没有参数，有参数就不是默认构造函数</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class Y&#123;</span></span><br><span class="line"><span class="code">		int a;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			Y(int a);		//有参数，不是默认构造函数</span></span><br><span class="line"><span class="code">	&#125;;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	class B&#123;</span></span><br><span class="line"><span class="code">		int b;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			B();		//没有参数，是默认</span></span><br><span class="line"><span class="code">	&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new------------对应-------------delete</span><br><span class="line">new <span class="language-xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>&gt;</span></span> 申请对应类的空间并返回指向改空间的地址</span><br><span class="line">new <span class="language-xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>&gt;</span></span>[<span class="language-xml"><span class="tag">&lt;<span class="name">num</span>&gt;</span></span>]------------对应-----------delete [] <span class="language-xml"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	a(new) --&gt; b[系统申请一片内存空间]</span><br><span class="line">	b --&gt; c[调用类对应的构造函数]</span><br><span class="line">	c --&gt; d(返回该空间的地址)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	a(delete) --&gt; b[调用类的析构函数]</span><br><span class="line">	b --&gt; c(回收内存空间)</span><br></pre></td></tr></table></figure>

<h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++运行时，会有一个inch table用于记录动态申请空间的变量表，记录申请的大小（单位是byte）和地址（首地址），所以若指向某数组空间的指针++后，调用delete时会报错，因为inch table中只记录了首地址</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];		<span class="comment">//new 10个int </span></span><br><span class="line"><span class="keyword">delete</span> [] psome;			<span class="comment">//new时使用了[]，delete时也要用[]，不带[]只会执行第一个对象的析构函数，[]会提示系统，这里要析构多个对象，且会从最后一个对象开始析构</span></span><br><span class="line">注<span class="number">1</span>：无论使不使用[]，空间都会收回，收回空间查inch table就可以知道要收回的大小和起始地址了，能运行但会死循环</span><br><span class="line">注<span class="number">2</span>：<span class="keyword">delete</span>可以<span class="keyword">delete</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_3](#解密new与delete	测试1	不带[]		&#x3D;&#x3D;检验代码_3&#x3D;&#x3D;)</p>
<p>[参考检验代码_4](#解密new与delete	测试2	带[]	&#x3D;&#x3D;检验代码_4&#x3D;&#x3D;)</p>
<h2 id="基础概念-5——访问控制-amp-amp-初始化列表（成员变量初始化首选，且父类的初始化只能初始化列表，否则父类得有默认构造函数）"><a href="#基础概念-5——访问控制-amp-amp-初始化列表（成员变量初始化首选，且父类的初始化只能初始化列表，否则父类得有默认构造函数）" class="headerlink" title="基础概念_5——访问控制&amp;&amp;初始化列表（成员变量初始化首选，且父类的初始化只能初始化列表，否则父类得有默认构造函数）"></a>基础概念_5——访问控制&amp;&amp;初始化列表（成员变量初始化首选，且父类的初始化只能初始化列表，否则父类得有默认构造函数）</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 基础知识：</span><br><span class="line"> 	public 公共的，任何人都可以访问</span><br><span class="line"> 	private 私有的，只有这个类的成员函数可以访问这个类的成员变量或成员函数，子类也不能直接访问，这是对类来说的，如果是同一个类的不同对象则它们之间可以相互访问对方的private 成员变量</span><br><span class="line"> 	protected 受保护的，只有这个类自己和它的子类可以访问，在其他地方则不能直接使用</span><br><span class="line"> 	friends	朋友，声明别的类，别的函数，或者别的类的某个函数是朋友，这样朋友就可以访问该类的private。一般用在运算符重载</span><br><span class="line">注：c++的访问控制只在编译环节存在，运行时其实没有访问控制。运行时对象b也可以访问对象a的私有变量和函数</span><br></pre></td></tr></table></figure>

<p>[参考检验代码_5](#解密new与delete				&#x3D;&#x3D;检验代码_5&#x3D;&#x3D;)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">类中的成员变量可以在构造函数中实现“初始化”，这样写实际是赋值，并非初始化，当成员变量是一个类，系统会去找该类的默认构造函数，当其没有默认构造函数时，报错。</span><br><span class="line">如：</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">A</span>()&#123;p=<span class="number">0</span>;i=<span class="number">0</span>;&#125;	<span class="comment">//在构造函数中初始化成员变量p和i</span></span><br><span class="line">		~<span class="built_in">A</span>();</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">使用初始化列表 格式：	构造函数(形参):&lt;成员变量<span class="number">1</span>&gt;(初始值<span class="number">1</span>), &lt;成员变量<span class="number">2</span>&gt;(初始值<span class="number">2</span>)&#123;&#125;		</span><br><span class="line">					<span class="built_in">name</span>(args)[:init-list]&#123;&#125;</span><br><span class="line">如：</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> *p;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">A</span>():<span class="built_in">p</span>(<span class="number">0</span>), <span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125; <span class="comment">//在构造函数:后使用初始化列表，这样写，p和i的初始化会在构造函数之前完成</span></span><br><span class="line">		~<span class="built_in">A</span>();</span><br><span class="line">	&#125;;</span><br><span class="line">注：当初始化</span><br></pre></td></tr></table></figure>

<h3 id="friend的使用"><a href="#friend的使用" class="headerlink" title="friend的使用"></a>friend的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注2：前项声明，一种用于通知编译器的方式，告诉编译器，有一个叫X的东西存在，因为Y中使用了X，不这样写会报错</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X*)</span></span>;		<span class="comment">//任何指针的大小都是一样的，且没有用到X内部的成员，因此前项声明可以使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">g</span><span class="params">(X*, <span class="type">int</span>)</span></span>;	<span class="comment">//函数朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Y::f</span><span class="params">(X*)</span></span>;	<span class="comment">//某个类的某个函数朋友，此处为Y类的f函数是X类朋友</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">Z</span>;		<span class="comment">//类/结构体朋友</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上在c++中主要拿到对象的地址就可以为所欲为，哪怕成员变量是private一样想改就改</span><br></pre></td></tr></table></figure>

<p>[参考检验代码_14](#C++ conversion				&#x3D;&#x3D;检验代码_14&#x3D;&#x3D;)</p>
<h2 id="基础概念-6——组合，继承，软件重用"><a href="#基础概念-6——组合，继承，软件重用" class="headerlink" title="基础概念_6——组合，继承，软件重用"></a>基础概念_6——组合，继承，软件重用</h2><h3 id="类的组合-composition"><a href="#类的组合-composition" class="headerlink" title="类的组合  composition"></a>类的组合  composition</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将一些已有的类的对象组合在一起拼凑成一个类，称为组合</span><br><span class="line">如：</span><br><span class="line"><span class="code">	现在有一个class engine的对象和class tyre的对象，把它们组合在一起，拼凑成一个class car</span></span><br><span class="line"><span class="code">即：</span></span><br><span class="line"><span class="code">	class中的成员变量可以是其他的class的对象</span></span><br><span class="line"><span class="code">分类：</span></span><br><span class="line"><span class="code">	Fully:当一个类就是另一个类的一部分时称为fully	就像肚子里的孩子</span></span><br><span class="line"><span class="code">	By reference:当一个类知道另一个类在哪里，能调用其方法，但其并非是它的一部分时称为by reference	就像已经生出来的孩子</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">在代码中，fully实际就是成员变量是一个类，而by reference是一个类的指针，指向的。</span></span><br><span class="line"><span class="code">	一般当一个类是另一个类的一部分时用fully形式，当一个类属于另一个类但不是其一部分时用by reference形式</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	人是一个类，书包是一个类，心脏是一个类，则心脏用fully形式，书包用by reference形式</span></span><br></pre></td></tr></table></figure>

<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Currency</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SavingAccount</span>&#123;</span><br><span class="line">   	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">SavingsAccount</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* address, <span class="type">int</span> cents); <span class="comment">//构造函数，有参数所以不是默认构造函数</span></span><br><span class="line">    	~<span class="built_in">SavingAccount</span>();	<span class="comment">//析构函数</span></span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;		<span class="comment">//一般成员函数</span></span><br><span class="line">   	<span class="keyword">private</span>:</span><br><span class="line">    	Person m_saver;		<span class="comment">//fully形式的组合</span></span><br><span class="line">    	Currency m_balance;	<span class="comment">//fully形式的组合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SavingAccount::<span class="built_in">SavingAccount</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* address, <span class="type">int</span> cents):<span class="built_in">m_saver</span>(name, address), <span class="built_in">m_balance</span>(<span class="number">0</span>,cents)&#123;&#125;; 	<span class="comment">//SavingAccount的构造函数，需要负责把其fully形式的成员变量初始化，类成员变量也需要，否则系统会去找其类成员变量的默认构造函数</span></span><br><span class="line">SavingAccount::<span class="built_in">print</span>()&#123;</span><br><span class="line">    m_saver.<span class="built_in">print</span>();	<span class="comment">//对象自己调用自己的print()</span></span><br><span class="line">    m_balance.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的继承-inheritance"><a href="#类的继承-inheritance" class="headerlink" title="类的继承 inheritance"></a>类的继承 inheritance</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用一个现有的类来改造，形成一个新的类</span><br><span class="line">如：</span><br><span class="line"><span class="code">	student继承于person则称student是person的超类，因为student继承于person则person有的student都有，但student还有一些person没有的，所以称student是person的superset，即超集</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">分类：</span><br><span class="line"><span class="code">	Base	基类</span></span><br><span class="line"><span class="code">	Super	超类</span></span><br><span class="line"><span class="code">	Parent	父类</span></span><br><span class="line"><span class="code">	Derived	派生类</span></span><br><span class="line"><span class="code">	Sub		次类</span></span><br><span class="line"><span class="code">	Child	子类</span></span><br><span class="line"><span class="code">使用方法：class B : public A&#123;&#125;;		B继承于A</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_6](#继承初体验				&#x3D;&#x3D;检验代码_6&#x3D;&#x3D;)</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	父类有的成员，子类继承后都会有，但是父类中private的成员子类不能直接用。相当于父辈给子辈留了一笔钱，但钱由信托保管，子辈不能直接使用。编译通不过。</span></span><br><span class="line"><span class="code">注：protected属性的成员则子类可以直接访问，相当于父类留了一些让子类访问父类private成员的接口，但这些接口别人不能使用</span></span><br></pre></td></tr></table></figure>

<h3 id="子类父类构造和析构的顺序"><a href="#子类父类构造和析构的顺序" class="headerlink" title="子类父类构造和析构的顺序"></a>子类父类构造和析构的顺序</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造</span><br><span class="line"><span class="code">	先调用父类构造函数，然后调用子类构造函数，</span></span><br><span class="line"><span class="code">注：此时若父类没有默认构造函数，则需要在子类的构造函数中使用初始化列表的方式初始化父类且需要给其传参数，即使用构造函数初始化，而非默认构造函数，不这样的话，若父类无默认初始化构造函数编译时就会报错</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">析构</span><br><span class="line"><span class="code">	先调用子类的析构函数，再调用父类的析构函数</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_7](#继承再体验				&#x3D;&#x3D;检验代码_7&#x3D;&#x3D;)</p>
<h3 id="名字隐藏（C-独有）"><a href="#名字隐藏（C-独有）" class="headerlink" title="名字隐藏（C++独有）"></a>名字隐藏（C++独有）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	当父类中有overload的成员函数，且和子类中的成员函数同名时，c++会自动隐藏父类中的那些成员函数，只保留的子类自己的成员函数</span></span><br><span class="line"><span class="code">注1：此时想调用父类的那些函数得用域解析符 ::</span></span><br><span class="line"><span class="code">注2：当子类和父类有同名且同参数的成员函数时，默认使用的是子类的成员函数，如果想要使用父类的则需要使用 域解析符 ::</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class A&#123;...&#125;;</span></span><br><span class="line"><span class="code">	class B : public A &#123;...&#125;;</span></span><br><span class="line"><span class="code">	B b;</span></span><br><span class="line"><span class="code">	b.func();	//使用B中的成员函数func</span></span><br><span class="line"><span class="code">	b.A::func();//使用A中的成员函数func</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_8](#c++名字隐藏				&#x3D;&#x3D;检验代码_8&#x3D;&#x3D;)</p>
<h2 id="基础概念-7——函数重载-amp-amp-内联函数"><a href="#基础概念-7——函数重载-amp-amp-内联函数" class="headerlink" title="基础概念_7——函数重载 &amp;&amp;内联函数"></a>基础概念_7——函数重载 &amp;&amp;内联函数</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重载——overloading</span><br><span class="line"><span class="code">	指一些函数可以具有相同的函数名，但它们的参数不一样（类型，个数...），调用函数时编译器会根据给出的参数来判断调用的哪一个函数</span></span><br><span class="line"><span class="code">注：返回类型不能作为构成overloading的条件</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">缺省值——default arguments（少用）</span><br><span class="line"><span class="code">	可以预先给函数的形参赋上值</span></span><br><span class="line"><span class="code">	写法：</span></span><br><span class="line"><span class="code">		int func(int i, int j, int k=1, int m=2)&#123;&#125;;</span></span><br><span class="line"><span class="code">注1：没有缺省值的形参要放在有缺省值的形参前面</span></span><br><span class="line"><span class="code">注2：如果有多个编译单元，即.cpp文件，记得一起编译，否则会找不到定义</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_9](#C++重载				&#x3D;&#x3D;检验代码_9&#x3D;&#x3D;)</p>
<h3 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a>特别注意：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缺省值一般是写在.h文件中，即写在函数声明中，当然函数的声明也可以写在.cpp文件中（这样的话，假如别人的函数实际上是没有缺省值的，但你在自己的.cpp文件中给它加上一个带有缺省值的声明也是可以的，且此时仅自己的.cpp文件中声明生效），且如果没有声明，只有定义也可以直接写在定义中</span><br></pre></td></tr></table></figure>

<p>[参考检验代码_10](#C++缺省声明探究				&#x3D;&#x3D;检验代码_10&#x3D;&#x3D;)</p>
<h3 id="内联函数-1"><a href="#内联函数-1" class="headerlink" title="内联函数"></a>内联函数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">提出原因：</span><br><span class="line"><span class="code">	函数调用涉及一系列的压栈出栈操作，在存在同一个函数大量调用时，影响效率，因此提出了内联函数</span></span><br><span class="line"><span class="code">使用方法：</span></span><br><span class="line"><span class="code">	inline &lt;callback type&gt; &lt;function_name&gt; ()&#123;&#125;</span></span><br><span class="line"><span class="code">原理：</span></span><br><span class="line"><span class="code">	当编译器检测到inline关键词时会将inline函数的代码嵌入到调用它的地方，且仍保持inline函数的独立性（函数有自己的变量，空间...）</span></span><br><span class="line"><span class="code">与C的#define的不同：</span></span><br><span class="line"><span class="code">	#define不做类型检查，inline定义的函数会对参数做类型检查</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	#define f(a) (a) + (a)		//不会检查传来的参数是什么类型</span></span><br><span class="line"><span class="code">	inline int f(int a)&#123;return a*2;&#125; //会检查传来的参数是否是int类型</span></span><br><span class="line"><span class="code">注：</span></span><br><span class="line"><span class="code">	当用户定义的inline太过复杂时，编译器可能会拒绝嵌入</span></span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上现在f(a)等价于 a + a，编译器会自己优化成这样</span></span><br></pre></td></tr></table></figure>

<h3 id="特别注意：-1"><a href="#特别注意：-1" class="headerlink" title="特别注意："></a>特别注意：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内联函数的要求：</span><br><span class="line"><span class="code">	当内联函数需要被其他编译单元调用时，需要将内联函数的函数体（即函数实现，定义）放在.h文件中，因为编译器要在调用的地方嵌入内联函数的代码，而编译器同一时间只能处理一个编译单元，所以必须在预处理时将内联代码放入调用其的编译单元内</span></span><br><span class="line"><span class="code">注1：只在本编译单元调用inline函数时，不用写到.h文件中（废话）</span></span><br><span class="line"><span class="code">注2：非常小的函数，编译器自动inline，太大的函数，inline无效，递归函数不要inline。建议只有两三行，且调用次数多的函数使用inline</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_11](#C++其他编译单元调用内联函数				&#x3D;&#x3D;检验代码_11&#x3D;&#x3D;)</p>
<h3 id="类中的内联函数"><a href="#类中的内联函数" class="headerlink" title="类中的内联函数"></a>类中的内联函数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当在类中直接给出成员函数的body时，编译器默认为inline</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::print&quot;</span> &lt;&lt; endl; &#125; 	<span class="comment">//默认为内联函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;								<span class="comment">//一般成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inline_test</span><span class="params">()</span></span>;			<span class="comment">//这也是inline型，只是放在类外面</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_i</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123; i = ii; &#125;				 <span class="comment">// inline型成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125; <span class="function"><span class="type">void</span> <span class="title">A::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; 											<span class="comment">//一般成员函数的body</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::inline_test</span><span class="params">()</span>   <span class="comment">//inline型成员函数的body，inline关键字不能省</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline A::inline_test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：这样写，从运行的效果来说，如果inline型的成员变量访问该类的成员变量，实际相当于直接访问成员变量，如a.set<span class="emphasis">_i(10)运行效率等价于a.i=10</span></span><br></pre></td></tr></table></figure>



<h2 id="基础概念-8——const"><a href="#基础概念-8——const" class="headerlink" title="基础概念_8——const"></a>基础概念_8——const</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">基础知识：</span><br><span class="line"><span class="code">	被const关键词修饰后，变量不能进行修改和再次赋值，但对于c++来说，const修饰后仍然还是变量，不是常数，仍然遵循一般变量的规则</span></span><br><span class="line"><span class="code">extern关键词可以声明该变量是一个定义在某处的变量</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	extern const int bufsize; //bufsize是某处的一个变量，且在此处是const的</span></span><br><span class="line"><span class="code">const的使用：</span></span><br><span class="line"><span class="code">	如果该变量用const修饰，且编译前已经知道了其具体值，此时则可以用于给数组确定大小，若编译前不知道值，则编译时报错，因为编译器不知道给该数组分配多大的空间</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	const int n = 12;</span></span><br><span class="line"><span class="code">	int array[n];		//可以使用</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	int x;cin&gt;&gt;x;</span></span><br><span class="line"><span class="code">	const int size = x;</span></span><br><span class="line"><span class="code">	int array[x];	//报错，编译器不知道应该分配多大空间给array</span></span><br><span class="line"><span class="code">同理，用extern const int bufsize; 这样也不能用来给数组分配空间，因为编译器不知道bufsize到底有多大</span></span><br></pre></td></tr></table></figure>

<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="type">const</span> q = <span class="string">&quot;abc&quot;</span>;		<span class="comment">//q这个指针是const的，即其指向的地址不能改变</span></span><br><span class="line">*q = <span class="string">&#x27;c&#x27;</span>;	<span class="comment">//可以</span></span><br><span class="line">q++;		<span class="comment">//不可以，其实就是指针的内容不能变，但指向的地址的内容可以变</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = <span class="string">&quot;ABCD&quot;</span>;	<span class="comment">//q这个指针指向的内容是const的</span></span><br><span class="line">*p = <span class="string">&#x27;b&#x27;</span>;	<span class="comment">//不可以，报错，即这个内容是不能改变的	实际是不能通过p指针来修改那个内存单元，而非是那个内存单元不可修改</span></span><br><span class="line">p++;	<span class="comment">//可以，指针的内容是可以变的</span></span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-总结-x3D-x3D"><a href="#x3D-x3D-总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> 在*前时，指针指向的内容是<span class="type">const</span>的，在*后时，指针是<span class="type">const</span>的。</span><br><span class="line">如：</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Bob&quot;</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">	<span class="type">const</span> Person* p = &amp;p1;	<span class="comment">//指针指向的对象为const</span></span><br><span class="line">	Person <span class="type">const</span>* p = &amp;p1;	<span class="comment">//指针指向的对象为const</span></span><br><span class="line">	Person *<span class="type">const</span> p = &amp;p1;	<span class="comment">//指针为const</span></span><br><span class="line">注<span class="number">1</span>：当指向的对象为<span class="type">const</span>时，并非说对象不可修改，而是指不能被这个指针所修改</span><br><span class="line">    <span class="comment">//一般用在，如要传一个对象给其他人，但直接传对象太麻烦了，要拷贝...，传指针快还方便，但害怕别人用传过去的指针修改对象，所以可以传const指针，这样就不能通过该指针修改了</span></span><br><span class="line">    </span><br><span class="line">注<span class="number">2</span>：用指针指向写死的字符串时默认是<span class="type">const</span>	如： <span class="type">char</span> *s = <span class="string">&quot;hello world&quot;</span>;这字符串是会放到代码段中，然后s指向其，编译器默认其为<span class="type">const</span></span><br><span class="line"><span class="comment">//但char s[] = &quot;hello world&quot;;则可以，因为系统会把代码段中的&quot;hello world&quot;拷贝到堆栈中的s数组中</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_12](#C++ const运用				&#x3D;&#x3D;检验代码_12&#x3D;&#x3D;)</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在函数后面加上const，一般出现在类中，意味着该函数不能修改该类的成员变量的值</span><br><span class="line">注：此时该函数声明和定义的地方都得加上const</span><br><span class="line">如：</span><br><span class="line"><span class="code">	class A&#123;</span></span><br><span class="line"><span class="code">	public:</span></span><br><span class="line"><span class="code">		A();</span></span><br><span class="line"><span class="code">		~A();</span></span><br><span class="line"><span class="code">		void test_func() const;		//声明一个带有const关键字的成员函数</span></span><br><span class="line"><span class="code">	private:</span></span><br><span class="line"><span class="code">		int i;</span></span><br><span class="line"><span class="code">	&#125;;</span></span><br><span class="line"><span class="code">	void A::test_func() const&#123;	//带有const关键字的成员函数的定义</span></span><br><span class="line"><span class="code">		i++;	//报错，const类型的成员函数无法修改成员变量的值</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">注1：实现原理实际上是编译器把this改成了带const关键字的this，所以该函数通过this无法修改成员变量，因为const &lt;pointer_type&gt;* p，p所指内容无法通过p修改</span></span><br><span class="line"><span class="code">注2：如果在一个对象前面加上const则该对象就没法被修改了</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	const A a;	//a的成员变量无法被修改，这样做没有意义</span></span><br></pre></td></tr></table></figure>

<h3 id="使用const来实现重载"><a href="#使用const来实现重载" class="headerlink" title="使用const来实现重载"></a>使用const来实现重载</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上就是默认参数this带了const关键字，所以可以重载</span><br></pre></td></tr></table></figure>

<p>[参考检验代码_13](#C++ const运用_2				&#x3D;&#x3D;检验代码_13&#x3D;&#x3D;)</p>
<h3 id="特别注意-1"><a href="#特别注意-1" class="headerlink" title="特别注意"></a>特别注意</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当对象带有const关键字时，要求将其所有成员变量在对象在初始化时都初始化（写在构造函数里面初始化和使用初始化列表初始化都可）。并且，如果要调用某个成员函数则该成员函数必须得有带const关键字的重载</span><br><span class="line"><span class="code">	实际上是因为当一对象带有const关键字时，其调用成员函数时，它传递的this是带有const关键字。因此当其调用某一成员函数，且该成员函数没有带const的重载时，相当于找不到对应函数</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">当对象有的成员变量是带有const关键字时，则这些成员变量需要在构造函数中初始化，且只能使用初始化列表初始化（只要成员变量带了const关键字，都必须使用初始化列表初始化）</span><br></pre></td></tr></table></figure>



<h2 id="基础概念-9——引用reference"><a href="#基础概念-9——引用reference" class="headerlink" title="基础概念_9——引用	reference"></a>基础概念_9——引用	reference</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">引用相当于给一个东西又取了一个名字</span><br><span class="line">如：</span><br><span class="line"><span class="code">	char c;</span></span><br><span class="line"><span class="code">	char&amp; r = c;	//即c和r是同一个字符的两个不同的名字</span></span><br><span class="line"><span class="code">使用方法：</span></span><br><span class="line"><span class="code">	一般情况：</span></span><br><span class="line"><span class="code">		type&amp; refname = name;</span></span><br><span class="line"><span class="code">		类型&amp; 引用的名字 = 被引用的目标;</span></span><br><span class="line"><span class="code">	参数表或成员变量时：</span></span><br><span class="line"><span class="code">		type&amp; refname</span></span><br><span class="line"><span class="code">注1：引用在定义时必须初始化，且让其初始化的东西必须是在内存空间有地址的</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	int&amp; z = i*3;	//报错，因为i*3只有结果，但结果没有储存在内存中</span></span><br><span class="line"><span class="code">和const搭配</span></span><br><span class="line"><span class="code">	const int&amp; z = x;	//z是x的引用但不能通过z去修改x的值 即z是read-only reference</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注2：&amp;也可以用在函数上</span><br><span class="line">如：</span><br><span class="line"><span class="code">	int&amp; func(); 	//即最后func函数返回的是一个int类型的引用</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注3：&amp;不能当作overload的参考，即如果想重载，但两个函数只有&amp;的区别，则报错</span><br><span class="line">如：</span><br><span class="line"><span class="code">	void func(int&amp; a);</span></span><br><span class="line"><span class="code">	void func(int a);</span></span><br><span class="line"><span class="code">	int x = 2;</span></span><br><span class="line"><span class="code">	func(x);	//报错，因为编译器不知道到底要找哪一个func函数</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注4：</span><br><span class="line"><span class="code">	实际上，reference的实现就是靠的const point，只是为了少一些*所以提出了reference，且一旦实现了引用就没办法去看这个引用自己的地址了，以后对其的操作都是在对其引用对象操作</span></span><br></pre></td></tr></table></figure>

<h3 id="特别注意-2"><a href="#特别注意-2" class="headerlink" title="特别注意"></a>特别注意</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">references和pointres的区别:</span><br><span class="line"><span class="code">	ref不能是null，point可以是</span></span><br><span class="line"><span class="code">	ref依赖于一个已经存在的变量，point则是独立于其他变量</span></span><br><span class="line"><span class="code">	ref一旦初始化后，就不能再改变引用对象，point可以改变指向对象</span></span><br><span class="line"><span class="code">	ref不能引用ref，point可以指向另外的point</span></span><br><span class="line"><span class="code">重点：</span></span><br><span class="line"><span class="code">   	有指针的引用，但没有引用的指针，就近原则，*离p近，p就是指针。&amp;离p近，p就是引用</span></span><br><span class="line"><span class="code">   	即：</span></span><br><span class="line"><span class="code">   		int&amp;* p;	 //报错，这里的意思是*p的类型是int ref的，即这个指针是int ref类型，出现了引用的指针</span></span><br><span class="line"><span class="code">   		void func(int*&amp; p);	 //可以，这里指p是ref，它引用的变量是int ref类型的，即指针的引用</span></span><br><span class="line"><span class="code">  	没有引用类型的数组，因为ref时间根本就不是实体，因此不能有数组</span></span><br></pre></td></tr></table></figure>



<h2 id="基础概念-10——转换-conversion，造型-amp-amp-多态性-amp-amp-覆写-overriding"><a href="#基础概念-10——转换-conversion，造型-amp-amp-多态性-amp-amp-覆写-overriding" class="headerlink" title="基础概念_10——转换 conversion，造型 &amp;&amp; 多态性  &amp;&amp; 覆写 overriding"></a>基础概念_10——转换 conversion，造型 &amp;&amp; 多态性  &amp;&amp; 覆写 overriding</h2><h3 id="转换-amp-amp-造型"><a href="#转换-amp-amp-造型" class="headerlink" title="转换&amp;&amp;造型"></a>转换&amp;&amp;造型</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果B类继承于A类，则主要是A可以使用的地方，B都可以使用。即子类的对象都可以当父类对象看待这叫upcast，向上造型</span><br><span class="line">把父类当子类看待叫downcast，有风险报错</span><br><span class="line">cast 造型和类型转换有区别</span><br></pre></td></tr></table></figure>

<p>[参考检验代码_14](#C++ conversion				&#x3D;&#x3D;检验代码_14&#x3D;&#x3D;)</p>
<h3 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态  polymorphism"></a>多态  polymorphism</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtual关键字：</span><br><span class="line"><span class="code">	成员函数前带有virtual意味着，如果该类的子类中重新写的该成员函数，则子类的那个成员函数和父类的成员函数有关系，且只要继承树中有一个祖先的函数带了virtual，其子子孙孙的那个同名函数都会默认带上virtual不管用户自己写不写上virtual。一般都写上方便看</span></span><br><span class="line"><span class="code">多态的实现：</span></span><br><span class="line"><span class="code">	upcast，向上造型，把子类对象当父类对象看待</span></span><br><span class="line"><span class="code">	Dynamic binding，动态绑定，运行时才知道到底调用的哪个函数</span></span><br></pre></td></tr></table></figure>

<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(Shape* p)</span></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//即这个p-&gt;render函数实际调用的是哪个render函数要得到运行时，传的哪个shape或shape类的子类的对象才知道，它会去调用该对象对应的render，这就叫多态，这里p就是多态的</span></span><br><span class="line"><span class="comment">//这里只要是shape或其子类都可以作为参数传进来</span></span><br><span class="line"><span class="comment">//而virtual的意思就是告诉编译器，不要把后面的render函数写死了，实际调用的哪一个render得看运行时是那个对象</span></span><br></pre></td></tr></table></figure>



<h3 id="x3D-x3D-特别注意-x3D-x3D"><a href="#x3D-x3D-特别注意-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;特别注意&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意&#x3D;&#x3D;</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注1：</span><br><span class="line"><span class="code">	任意一个类只要有带有virtual的成员函数则其大小就要比正常的类大且此时编译器会在实例化对象时给对象加上一个隐藏的成员变量vtpr指针，该指针指向这个类的vtable表，所有同一个类的实例化对象都指向同一个表，表中就是该类的各个虚函数的地址。而多态就是把子类的vtable中的虚函数地址换成了子类自己实现的那个虚函数的地址，如果子类没有自己声明那个虚函数则默认填上父类的那个虚函数的地址</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_15](#C++ virtual关键字				检验代码_15)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注2：</span><br><span class="line"><span class="code">	通过赋值将子类对象赋值即 = 给父类对象，则父类的对象的vtpr仍不变。但可以通过指针来强行改变对象的vtpr指向。如果是通过指向子类对象的指针赋值给指向父类的指针，则实际是指针指向变了，俩对象都没变化</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_16](#C++ 魔改vtpr				&#x3D;&#x3D;检验代码_16&#x3D;&#x3D;)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注3：</span><br><span class="line"><span class="code">	析构函数一般要用virtual格式，因为当把一个子类对象传给一个父类指针时，若delete该指针，当析构函数不是虚函数时，调用的就是父类的析构函数去析构的子类对象（静态绑定编译器直接把对应函数地址写死在那），只有当析构函数是虚函数时，才调用的是子类的析构函数（动态绑定编译器搞出个vtpr，用的时候去找vtable看用哪个函数）</span></span><br></pre></td></tr></table></figure>

<h3 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当子类覆写父类的成员函数后，又想使用父类的成员函数时要用 域解析符 ::</span><br><span class="line">如：</span><br><span class="line"><span class="code">	class A&#123;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			virtual void f();</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	class B : public A&#123;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			virtual void f()&#123;</span></span><br><span class="line"><span class="code">				A::f();</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_17](#C++ 覆写				&#x3D;&#x3D;检验代码_17&#x3D;&#x3D;)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line"><span class="code">	当父类中的某成员函数即有重载（overload）又有覆写（override），则子类必须覆写所有的重载，否则会发送name hidden（函数隐藏）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">重载和覆盖（覆写）的区别：</span><br><span class="line"><span class="code">	虚函数是基类希望派生类重新定义的函数，派生类重新定义基类虚函数的做法叫做覆盖；重载就在允许在相同作用域中存在多个同名的函数，这些函数的参数表不同。重载的概念不属于面向对象编程，编译器根据函数不同的形参表对同名函数的名称做修饰，然后这些同名函数就成了不同的函数。重载的确定是在编译时确定，是静态的；虚函数则是在运行时动态确定。</span></span><br></pre></td></tr></table></figure>



<h2 id="基础概念-11——引用再体验"><a href="#基础概念-11——引用再体验" class="headerlink" title="基础概念_11——引用再体验"></a>基础概念_11——引用再体验</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注1：</span><br><span class="line"><span class="code">	当类中的成员变量是引用类型时，必须使用初始化列表来初始化该成员变量</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class A&#123;</span></span><br><span class="line"><span class="code">		private:</span></span><br><span class="line"><span class="code">			int&amp; i;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			X(int&amp; a);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	X::X(int&amp; a) : i(a) &#123;&#125;		//初始化列表也可以写在类外面</span></span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-特别注意-x3D-x3D-1"><a href="#x3D-x3D-特别注意-x3D-x3D-1" class="headerlink" title="&#x3D;&#x3D;特别注意&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意&#x3D;&#x3D;</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">	当函数要返回一个ref（引用）时，更倾向于返回一个非本地变量（因为离开该函数，本地变量就不存在了），然后就出现了，一个函数的返回值做了赋值符号的左值</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	func(3) = 21;</span></span><br><span class="line"><span class="code">注：</span></span><br><span class="line"><span class="code">	当函数的形参是ref类型时，向函数传递temporary value（就是那些在内存空间没有储存的地址的值，如23，i*2这种实际上是系统用一个const int型的匿名变量来接值，若非要用一个参数是const int&amp; 的函数来接也是可以实现的😂）</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_18](#C++ 引用再体验				&#x3D;&#x3D;检验代码_18&#x3D;&#x3D;)</p>
<p>[参考检验代码_19](#C++ 匿名变量				&#x3D;&#x3D;检验代码_19&#x3D;&#x3D;)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">结论：</span><br><span class="line"><span class="code">	在给一些函数传递对象时的方法</span></span><br><span class="line"><span class="code">A a;			//a是A类的对象</span></span><br><span class="line"><span class="code">法1：</span></span><br><span class="line"><span class="code">	func(A x);	//func函数的形参格式</span></span><br><span class="line"><span class="code">	func(a);	//直接传对象，系统会再拷贝一次对象a，占空间，耗时长</span></span><br><span class="line"><span class="code">法2：</span></span><br><span class="line"><span class="code">	func(A* x);</span></span><br><span class="line"><span class="code">	func(&amp;a);	//传a的地址，不安全，func可以通过x指针修改a中成员变量</span></span><br><span class="line"><span class="code">法3：</span></span><br><span class="line"><span class="code">	func(const A* x);	</span></span><br><span class="line"><span class="code">	func(&amp;a);	//传a的地址，且不能通过x指针修改a中的成员变量</span></span><br><span class="line"><span class="code">法4：通法</span></span><br><span class="line"><span class="code">	func(const A&amp; x);</span></span><br><span class="line"><span class="code">	func(a);	//同上，只是不用在func函数中写很多的*，因为指针要使用时得用*来表示该操作是对指向空间的操作</span></span><br></pre></td></tr></table></figure>

<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">注意区分函数返回的是值还是变量</span><br><span class="line">如：</span><br><span class="line"><span class="code">	class A&#123;...&#125;;</span></span><br><span class="line"><span class="code">	A func()&#123;	//这个返回的是一个变量，返回值可以作 = 的左值，但是作完左值后，就没办法控制这个变量了，它相当于消失了</span></span><br><span class="line"><span class="code">		A a;</span></span><br><span class="line"><span class="code">		return a;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	int func()&#123;		//这个返回的是一个值 10，返回值不可以作 = 的左值</span></span><br><span class="line"><span class="code">		int i = 10;</span></span><br><span class="line"><span class="code">		return 10;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="基础概念-12——拷贝构造"><a href="#基础概念-12——拷贝构造" class="headerlink" title="基础概念_12——拷贝构造"></a>基础概念_12——拷贝构造</h2><h3 id="x3D-x3D-特别注意-x3D-x3D-2"><a href="#x3D-x3D-特别注意-x3D-x3D-2" class="headerlink" title="&#x3D;&#x3D;特别注意&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意&#x3D;&#x3D;</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">初始化initialization和赋值assignment的区别</span><br><span class="line"><span class="code">	int i = 10;		//初始化且赋值，初始化只能有一次</span></span><br><span class="line"><span class="code">	i = 12;			//赋值，赋值可以有多次</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注1：c++中既可以使用 = 来初始化对象，又可以使用 () 来初始化，使用 = 时需要存在一个构造函数的参数是 = 的右值</span><br><span class="line">如：</span><br><span class="line"><span class="code">	class A &#123;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			A();</span></span><br><span class="line"><span class="code">			A(int i);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	A a; //调用A()构造函数</span></span><br><span class="line"><span class="code">	A a = 10; //调用A(int i)构造函数</span></span><br><span class="line"><span class="code">	A a(10); //等价于上一句</span></span><br><span class="line"><span class="code">注2：</span></span><br><span class="line"><span class="code">	当初始化时使用另外一个同一个类的对象来初始化一个对象，这就叫拷贝构造</span></span><br><span class="line"><span class="code">拷贝构造函数，自己不定义时，编译器会自动给出（默认拷贝每一个成员变量，如果有另外的类的对象，则会用对应的那个类的拷贝构造来拷贝这个成员变量，这是成员对成员的拷贝，即有成员变量是类的对象时是通过拷贝构造函数来拷贝的，不是字节对字节的拷贝），格式就是构造函数只是参数是这类的对象的const 引用</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class A &#123;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			A();	//默认构造函数</span></span><br><span class="line"><span class="code">			A(const A&amp; );	//拷贝构造函数，&amp; 不能省，不然编译器会告诉你，你写错了🤣，因为不写&amp;就会反复发生拷贝构造还没法跳出循环</span></span><br><span class="line"><span class="code">			A(int i);	//自定义构造函数</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	A a; //调用A()构造函数</span></span><br><span class="line"><span class="code">	A a = 10; //调用A(int i)构造函数</span></span><br><span class="line"><span class="code">	A a(10); //等价于上一句 </span></span><br><span class="line"><span class="code">注3：当类中的成员变量有指针时，拷贝构造函数默认会把拷贝出来的对象的那个指针成员变量指向，被拷贝的对象的那个对应的指针指向的内存空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">拷贝构造发生在用一个对象去初始化的另一个对象时，有显然情景和隐藏情景</span><br><span class="line">显然情景：</span><br><span class="line"><span class="code">	A a;</span></span><br><span class="line"><span class="code">	A b = a;		//显然用一个对象去初始化另一个对象</span></span><br><span class="line"><span class="code">	A b(a);		//等价于上一条语句，只是写的方式不一样</span></span><br><span class="line"><span class="code">隐藏情景——1：</span></span><br><span class="line"><span class="code">	func(A b);</span></span><br><span class="line"><span class="code">	A a;</span></span><br><span class="line"><span class="code">	func(a);	//在函数调用传递参数时发生拷贝构造</span></span><br><span class="line"><span class="code">隐藏情景——2：</span></span><br><span class="line"><span class="code">	A func(...);</span></span><br><span class="line"><span class="code">	A a = func(...);	//在函数返回时发生拷贝构造</span></span><br><span class="line"><span class="code">注：</span></span><br><span class="line"><span class="code">	把拷贝构造函数放在private下面，可以让别人没法用该类的对象来构造另一个对象，不能拿来直接当函数参数传递</span></span><br></pre></td></tr></table></figure>



<h2 id="基础概念-13——静态-Static"><a href="#基础概念-13——静态-Static" class="headerlink" title="基础概念_13——静态 Static"></a>基础概念_13——静态 Static</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static——c：</span><br><span class="line"><span class="code">	一个全局变量是static的指该变量只在那个.c文件中有效</span></span><br><span class="line"><span class="code">	一个本地变量是static的指该本地变量具有持久储存（离开这个函数，进入其他函数，该变量依然存在不会被销毁，实际上一个本地变量加上static后就是全局变量）</span></span><br><span class="line"><span class="code">	一个函数是static的指该函数只能在那个.c文件中被访问</span></span><br><span class="line"><span class="code">static——c++：</span></span><br><span class="line"><span class="code">	带static关键字的本地变量，意味着该变量持久储存，但只能在该函数内部访问</span></span><br><span class="line"><span class="code">	带static关键字的成员变量，意味着该变量可以被该类所有的对象访问，即被所有实例共享，但该变量只会初始化一次</span></span><br><span class="line"><span class="code">	带static关键字的成员函数，意味着该函数可以被该类所有的对象使用，即被所有的实例共享，但该函数只能访问带有static关键字的成员变量</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">全局变量的构造函数在程序运行时，main函数执行前执行。它的析构函数在程序结束后main函数结束时调用</span><br><span class="line">注：</span><br><span class="line"><span class="code">	c++多个文件中全局变量的初始化是没有固定顺序的，所以当全局变量之前相互有依赖关系时，要么把有依赖的全局变量全写在用一个文件中，要么别这样写</span></span><br></pre></td></tr></table></figure>

<h3 id="static-成员变量（实际上就是把那个变量搞成了全局变量，且声明其是某个类的全局变量）"><a href="#static-成员变量（实际上就是把那个变量搞成了全局变量，且声明其是某个类的全局变量）" class="headerlink" title="static 成员变量（实际上就是把那个变量搞成了全局变量，且声明其是某个类的全局变量）"></a>static 成员变量（实际上就是把那个变量搞成了全局变量，且声明其是某个类的全局变量）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"><span class="code">	直接写static int i;这是声明，不是定义，编译能过，但链接过不了，这语句类似于extern int i;即告诉编译器有一个i存在，但在哪并没有说</span></span><br><span class="line"><span class="code">实际使用需在某处给出static成员变量的定义</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class A&#123;</span></span><br><span class="line"><span class="code">	public:</span></span><br><span class="line"><span class="code">		A();</span></span><br><span class="line"><span class="code">		virtual ~A();</span></span><br><span class="line"><span class="code">		A(const A&amp; );</span></span><br><span class="line"><span class="code">	private:</span></span><br><span class="line"><span class="code">		static int i;	//A类中带有static关键字的i的声明</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	int A::i;	//i的定义，没有这句，链接报错，提示找不到i，这句就是正常的定义，除了多了个类名和域解析符，也写成 int A::i = 123;都可以</span></span><br><span class="line"><span class="code">带static关键字的成员变量，是类的所有对象共享的，且怎能在它定义处初始化，不能用初始化列表来初始化</span></span><br><span class="line"><span class="code">注：如果成员变量带有static关键字则哪怕没有实例化任何该类的对象，仍然可以通过&lt;class_name&gt;::&lt;var_name&gt;();来使用该成员变量</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_20](#C++ 静态成员变量				&#x3D;&#x3D;检验代码_20&#x3D;&#x3D;)</p>
<h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果成员函数带有static关键字则哪怕没有实例化任何该类的对象，仍然可以通过<span class="language-xml"><span class="tag">&lt;<span class="name">class_name</span>&gt;</span></span>::<span class="language-xml"><span class="tag">&lt;<span class="name">func_name</span>&gt;</span></span>();调用该成员函数</span><br><span class="line"></span><br><span class="line">注：静态的成员函数只能访问静态的成员变量，连this这个隐藏变量都不能使用（也就是说静态成员函数没有隐藏变量this），因为你甚至可以不实例化对象来调用它，要是它能访问this岂不是找了个寂寞🙌</span><br></pre></td></tr></table></figure>



<h2 id="基础概念-13——运算符重载"><a href="#基础概念-13——运算符重载" class="headerlink" title="基础概念_13——运算符重载"></a>基础概念_13——运算符重载</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c++中能够被重载的运算符：</span><br><span class="line"><span class="bullet">	+</span> - * / % ^ &amp; | ~</span><br><span class="line"><span class="code">	= &lt; &gt; += -= *= /= %= ^= &amp;= |=</span></span><br><span class="line"><span class="code">	&lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == != &lt;= &gt;= ! &amp;&amp; || ++ --</span></span><br><span class="line"><span class="code">	, -&gt;* -&gt; () []</span></span><br><span class="line"><span class="code">	operator new	operator delete		//你没看错，new和delete都能重载😮</span></span><br><span class="line"><span class="code">	operator new[]	operator delete[]</span></span><br><span class="line"><span class="code">c++中不能重载的运算符：</span></span><br><span class="line"><span class="code">	.	.*	::	?:</span></span><br><span class="line"><span class="code">	sizeof	typeid</span></span><br><span class="line"><span class="code">	static_cast	dynamic_cast const_cast reinterpret_cast</span></span><br><span class="line"><span class="code">注1：运算符重载只针对已有的运算符，你不能自己搞一个颜文字来重载。运算符重载只是针对自己定义的类或者其他什么自定义数据类型（枚举...）</span></span><br><span class="line"><span class="code">注2：不能重载基础的数据类型的运算符，什么int的加法重载成减法那是不行的</span></span><br><span class="line"><span class="code">注3：不能重载操作数个数，即不能把二目运算符改成三目运算符，还不能改运算的优先级</span></span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">运算符重载实际上就是为那个运算符写一个特别的函数，该函数前面要使用operator关键字</span><br><span class="line">该函数可以作为某个类的成员函数</span><br><span class="line">如：</span><br><span class="line"><span class="code">	const String String::operator +(const String&amp; that);</span></span><br><span class="line"><span class="code">该函数返回一个带const关键字的String类的对象，需要一个String对象参数（+ 需要两个算子，但String是一个类，所以当其对象使用自己所属类的成员函数时，自带一个this，因此只需要一个参数就可以了）</span></span><br><span class="line"><span class="code">该函数也可以作为全局函数</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	const String operator +(const String&amp; r, const String&amp; l);</span></span><br><span class="line"><span class="code">参数列表中用的带const关键字的引用是为了防止在该函数内部对对象的成员变量进行修改（加法是不会修改两算子的值），因为这不是某个类的成员函数，所有需要两个算子</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注：这里返回值也带const的原因是因为防止出现返回结果作左值的情况</span><br><span class="line">如：出现</span><br><span class="line"><span class="code">	a + b = 6;	这种操作，编译通不过</span></span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-特别注意-x3D-x3D-3"><a href="#x3D-x3D-特别注意-x3D-x3D-3" class="headerlink" title="&#x3D;&#x3D;特别注意&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意&#x3D;&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">在c++中运算符的左边算子称为receiver，编译器通过左边算子来确定，这个运算符应该用哪个重载的函数</span><br><span class="line">如：</span><br><span class="line">	<span class="function">Integer <span class="title">x</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">5</span>)</span>, z</span>;	<span class="comment">//初始化x, y, z（为赋值）</span></span><br><span class="line">	x + y;	<span class="comment">//实际等价于x.operator+(y)，receiver是x</span></span><br><span class="line">	z = x + y;	<span class="comment">//使用的是Interger的 + ，receiver是x</span></span><br><span class="line">	z = x + <span class="number">3</span>;	<span class="comment">//使用的是Interger的 + ，receiver是x，且3会被先构造成一个你匿名的Interger的对象（Interger有一个参数为int的构造函数）</span></span><br><span class="line">	z = <span class="number">3</span> + y; 	<span class="comment">//用的是int的+，receiver是3，此时需要int有一个通过Integer构造int的构造函数，否则报错，编译不过</span></span><br><span class="line"></span><br><span class="line">一目运算符</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> Integer <span class="keyword">operator</span>-() <span class="type">const</span>&#123;	<span class="comment">//只需要一个算子的运算符，作为成员函数时不需要参数，因为默认有个this，函数返回值带const是为了防止返回结果作左值，函数带const是为了不修改作运算的对象的值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Integer</span>(-i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">z = -x;	<span class="comment">//等价于z.operator=(x.operator-());</span></span><br><span class="line"></span><br><span class="line">注：一目运算符使用全局函数重载时，一般要在操作的类中使用关键字<span class="keyword">friend</span>声明</span><br><span class="line">如：</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">friend</span> <span class="type">const</span> Integer <span class="keyword">operator</span>+(<span class="type">const</span> Integer&amp; lhs, <span class="type">const</span> Integer&amp; rhs);	<span class="comment">//声明这个函数是friend，其可以访问Integer类的成员变量（private的成员变量也可以访问）</span></span><br><span class="line">		...</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> Integer <span class="keyword">operator</span>+(<span class="type">const</span> Integer&amp; lhs, <span class="type">const</span> Integer&amp; rhs)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Integer</span>(lhs.i + rhs.i);</span><br><span class="line">	&#125;	<span class="comment">//重载 + 的函数的body，返回值加const防止返回结果作左值，形参加const防止修改算子的值</span></span><br><span class="line">	z = x + y;	<span class="comment">//可以，完全符合这个全局重载函数的参数列表</span></span><br><span class="line">	z = x + <span class="number">3</span>;	<span class="comment">//可以，receiver是x，Integer类有一个自己的运算符重载函数，会先把3构造成一个匿名的Integer对象，在调用全局重载函数</span></span><br><span class="line">	z = <span class="number">3</span> + x;	<span class="comment">//可以，会默认把3构造成一个匿名的Integer对象，再调用这个全局重载函数</span></span><br><span class="line">	z = <span class="number">3</span> + <span class="number">7</span>;	<span class="comment">//可以，receiver是3，调用int::operator+()把结果10返回来后用构造函数构造成一个Integer之后在赋值给z</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">关于是否把对一个类的运算符重载函数做成成员函数：</span><br><span class="line"><span class="bullet">1.</span>	单目运算符重载应该做成成员函数</span><br><span class="line"><span class="bullet">2.</span>	= () [] -&gt; -&gt;* 这几个必须做成成员函数</span><br><span class="line"><span class="bullet">3.</span>	其他的所有二目运算符做成非成员函数（使用friend关键字在类中声明）</span><br><span class="line"></span><br><span class="line">关于运算符重载函数的参数设置：</span><br><span class="line"><span class="bullet">1.</span>	如果该运算符不会修改算子，则形参要用const修饰，如：+ - =</span><br><span class="line"><span class="bullet">2.</span>	如果该运算符要修改算子，则形参不能有const修饰，如：++ -- </span><br><span class="line"><span class="bullet">3.</span>	如果运算结果不能作左值，则函数需要用const修饰，如：+ -</span><br><span class="line"><span class="bullet">4.</span>	如果运算结果可以作左值，则函数不要用const修饰，如：[]</span><br><span class="line"><span class="bullet">5.</span>	如果是类成员函数，且运算结果是会修改该类对象，则该函数不能用const来修饰</span><br></pre></td></tr></table></figure>

<h3 id="常见的运算符原型"><a href="#常见的运算符原型" class="headerlink" title="常见的运算符原型"></a>常见的运算符原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	+-*/%&amp;|~</span><br><span class="line">	<span class="function"><span class="type">const</span> T <span class="title">operatorX</span><span class="params">(<span class="type">const</span> T&amp; i, <span class="type">const</span> T&amp;r)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="number">2.</span>	! &amp;&amp; || &lt; &lt;= == &gt;= &gt;</span><br><span class="line">	<span class="type">bool</span> <span class="built_in">operatorX</span>(<span class="type">const</span> T&amp;i, <span class="type">const</span> T&amp;r)<span class="type">const</span>;</span><br><span class="line"><span class="number">3.</span>	[]</span><br><span class="line">	T&amp; T::<span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br><span class="line"><span class="number">4.</span>	++</span><br><span class="line">prefix ++（++在算子前）：</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>++();	<span class="comment">//返回的是加完后的结果，如：++a，返回的是a加完后的结果</span></span><br><span class="line">定义的例子(具体怎么实现得看具体对象)：</span><br><span class="line"><span class="type">const</span> Integer&amp; Integer::<span class="keyword">operator</span>++()&#123;	<span class="comment">//这里函数返回值带ref更方便，要是直接返回一个对象则会发生拷贝构造</span></span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postifx ++（++在算子后）:</span><br><span class="line">	<span class="type">const</span> T <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">//返回的是加完前的结果，如：a++，返回的是a加完前的a</span></span><br><span class="line">定义的例子：</span><br><span class="line"><span class="type">const</span> Integer Integer::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;	<span class="comment">//这里函数返回值没有带ref是因为不能返回一个本地变量的ref，因为离开了这个函数，本地变量就不存在了</span></span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;	<span class="comment">//拷贝构造</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);		<span class="comment">//调用上面的prefix ++函数</span></span><br><span class="line">    <span class="keyword">return</span> old;		<span class="comment">//返回一个对象，在发生一次拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span>	--</span><br><span class="line">道理同++</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">注：++和--中prefix和postfix参数不一样是为了做重载，编译时，调用postfix函数编译器会自动给一个 <span class="number">0</span> 作为参数</span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span> [] index运算符</span><br><span class="line">    返回的是成员的引用，因为可以用来作左值</span><br></pre></td></tr></table></figure>

<h3 id="奇淫巧计"><a href="#奇淫巧计" class="headerlink" title="奇淫巧计"></a>奇淫巧计</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">对于关系运算符：&gt; &lt; &gt;= &lt;= == !=	只需要定义&lt;和==即可，其他的都可以通过这俩来推出</span><br><span class="line">如：</span><br><span class="line">bool Integer::operator==( const Integer&amp; rhs) const &#123;</span><br><span class="line"><span class="code">	return i == rhs.i;			//定义了 ==</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">bool Integer::operator!=( const Integer&amp; rhs) const &#123;</span></span><br><span class="line"><span class="code">	return !(*this == rhs);		//调用了 == </span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">bool Integer::operator&lt;( const Integer&amp; rhs) const &#123;</span></span><br><span class="line"><span class="code">	return i &lt; rhs.i;			//定义了 &lt;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">bool Integer::operator&gt;( const Integer&amp; rhs) const &#123;</span></span><br><span class="line"><span class="code">	return rhs &lt; *this;	//调用了 &lt;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">bool Integer::operator&lt;=( const Integer&amp; rhs) const &#123;</span></span><br><span class="line"><span class="code">	return !(rhs &lt; *this); //调用了 &lt;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">bool Integer::operator&gt;=( const Integer&amp; rhs) const &#123;</span></span><br><span class="line"><span class="code">	return !(*this &lt; ths); //调用了 &lt;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注：这样写的好处是，以后要修改代码，只需要改两处地方即可</span><br></pre></td></tr></table></figure>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">如果没有给一个类的赋值运算符重载函数，则编译器会自动创造一个赋值运算符的重载</span><br><span class="line">T::operator=(T)&#123;&#125;进行一个memberwise的赋值操作，即有成员变量是其他类则要调用那个类的赋值运算符重载函数</span><br><span class="line"></span><br><span class="line">注1：如果要自己实现赋值运算符的重载函数，则该函数一定要是成员函数，且是对自己赋值然后返回自己</span><br><span class="line">如：</span><br><span class="line"><span class="code">	T&amp; T::operator=(const T&amp; rhs)&#123;</span></span><br><span class="line"><span class="code">		if(this != &amp;rhs)&#123;	//当自己不是赋值给自己时才做赋值操作，否则直接返回自己</span></span><br><span class="line"><span class="code">			//assignmeng的具体实现</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		return *this;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">注2：if检查在类有动态申请内存（有指针成员变量）的时候要写，否容易出现问题</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class A&#123;</span></span><br><span class="line"><span class="code">		private:</span></span><br><span class="line"><span class="code">			char *p;</span></span><br><span class="line"><span class="code">		public:</span></span><br><span class="line"><span class="code">			A&amp; operator=(const&amp; A that)&#123;		//此时当出现某对象自己给自己赋值时报错，因为p已经被delete了，that.p不存在，直接报错，要不就读到别人地址了</span></span><br><span class="line"><span class="code">				delete p;</span></span><br><span class="line"><span class="code">				p = new [strlen(that.p)+1];</span></span><br><span class="line"><span class="code">				strcpy(p, that.p);</span></span><br><span class="line"><span class="code">				return *this;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>	自动类型转换</span><br><span class="line"><span class="code">	当一个函数f的参数需要类A的变量，但类A有一个参数为类B的构造函数，此时给f一个B的对象，仍然不会出错。因为系统会自动调用A的对应的那个构造函数来通过B的对象来构造一个A的临时匿名对象传给f函数，如果不想系统自动转换则需要在该构造函数前加上explicit关键字</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span>	默认的自动转换（=&gt; 的意思相当于是可以把 =&gt; 左边的东西直接传给右边）：</span><br><span class="line"><span class="code">	Primitive（小范围 =&gt; 大范围）：</span></span><br><span class="line"><span class="code">		char =&gt; short =&gt; int =&gt; float =&gt; double</span></span><br><span class="line"><span class="code">					 =&gt; int =&gt; long</span></span><br><span class="line"><span class="code">	Implicit(对于单独某个类来说)：</span></span><br><span class="line"><span class="code">		T =&gt; T&amp;,	绑定</span></span><br><span class="line"><span class="code">		T&amp; =&gt; T,	初始化/赋值</span></span><br><span class="line"><span class="code">		T* =&gt; void*,	去除指针类型，简称退型，指针仍指向那片地址空间，但指针没有类型了</span></span><br><span class="line"><span class="code">		T =&gt; const T,	把一个变量当const看待</span></span><br><span class="line"><span class="code">		T[] =&gt; T*,	数组可以用指针来控制</span></span><br><span class="line"><span class="code">		T* =&gt; T[],	指针可以用数组来控制</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">3.</span>	专用类型转换（T =&gt; C，不同类型之间的转换）</span><br><span class="line"><span class="code">	使用专用类型转换函数</span></span><br><span class="line"><span class="code">	类中声明：operator target_class();</span></span><br><span class="line"><span class="code">	类外定义：X::operator target_class()&#123;...&#125;</span></span><br><span class="line"><span class="code">	作用：将X类的对象转换为target_class类的对象</span></span><br><span class="line"><span class="code">	专用的类型转换函数，该函数没有写返回类型，实际上target_class就是返回类型，target_class可以是任何系统和自定义的类</span></span><br><span class="line"><span class="code">如：</span></span><br><span class="line"><span class="code">	class Rational &#123;</span></span><br><span class="line"><span class="code">	public:</span></span><br><span class="line"><span class="code">		...</span></span><br><span class="line"><span class="code">		operator double() const;	//将rational类转换为double类型</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	Rational::operator double() const &#123;</span></span><br><span class="line"><span class="code">		return numerator_/(double) denominator_;	//实现转换，瞎写的，这里是在举例子怎么写</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">注：不能出现：</span><br><span class="line"><span class="bullet">	1.</span> A类中有一个转换为B类的专用类型转换函数a<span class="emphasis">_to_</span>b()</span><br><span class="line"><span class="bullet">	2.</span> B类中有一个以A类对象为参数的构造函数B(A&amp; a)</span><br><span class="line"><span class="bullet">	3.</span> 有一个函数f需要一个B类对象，但传给f了一个A类的对象</span><br><span class="line"><span class="code">	此时报错，因为编译器不知道用a_to_b函数还是B(A&amp; a)函数，它俩没有优先级区别，此时要么删掉一个，或者在B(A&amp; a)函数前加上explicit关键字免得系统自动调用这个构造函数</span></span><br></pre></td></tr></table></figure>

<p>[参考检验代码_21](#C++ 自动类型转换				&#x3D;&#x3D;检验代码_21&#x3D;&#x3D;)</p>
<h2 id="基础概念-14——模板——Template"><a href="#基础概念-14——模板——Template" class="headerlink" title="基础概念_14——模板——Template"></a>基础概念_14——模板——Template</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一种重用代码的方式，此时变量类型成为参数，可以有两种Template，function和class两种</span><br></pre></td></tr></table></figure>

<h3 id="1-函数模板——function-template"><a href="#1-函数模板——function-template" class="headerlink" title="1.函数模板——function template"></a>1.函数模板——function template</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一种模板用来做出函数，相当于告诉编译器，它要怎么帮你做出一个函数</span></span><br><span class="line">如：</span><br><span class="line">使用一般函数：</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>&#123;	<span class="comment">//这个函数只能交换俩int类型的变量</span></span><br><span class="line">		<span class="type">int</span> temp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = temp;</span><br><span class="line">	&#125;</span><br><span class="line">使用函数模板：</span><br><span class="line">	<span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt;	<span class="comment">//template是关键字，class T是用来代表任意类型（你要是喜欢也可以用X）（实际上就是用来占位的，可以有多个如：template &lt;class T1, class T2&gt;，逗号隔开即可），这一语句下面是函数那就是函数模板，是类那就是类模板，即下面的swap函数就是函数模板，T代表任意的类型可以是基本类型也可以是用户自定义类型</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(T&amp; x, T&amp; y)</span></span>&#123;	</span><br><span class="line">		T temp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = tmep;</span><br><span class="line">	&#125;</span><br><span class="line">注<span class="number">1</span>：实际上上面的代码是declaration（声明），编译器会把这段代码记录下来，以后遇到调用swap时，会用那个模板把T变成调用处对应的类型X（随便用个字母表示），自动做出一个参数是X类型的swap函数（和其他的swap形成重载）</span><br><span class="line"></span><br><span class="line">注<span class="number">2</span>：使用函数模板后系统会ban掉显示（<span class="keyword">explicit</span>）自动类型转换和隐式（implicit）类型转换，如上面例子中<span class="built_in">swap</span>(<span class="type">int</span>,<span class="type">int</span>);可以，但<span class="built_in">swap</span>(<span class="type">int</span>,<span class="type">double</span>);不行</span><br><span class="line"></span><br><span class="line">注<span class="number">3</span>：重载规则，检查是否只有唯一的函数匹配--否--&gt;检查是否只有唯一的函数模板匹配--否--&gt;找重载函数</span><br><span class="line"></span><br><span class="line">注<span class="number">4</span>：如果函数模板的函数中没有使用到占位的<span class="keyword">class</span> <span class="title class_">T</span>，则在调用时需显示的给出标识用哪种类型如：</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span> )</span></span>&#123;...&#125;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">int</span>&gt;();	<span class="comment">//此时 T 的type是int </span></span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="type">float</span>&gt;();	<span class="comment">//此时 T 的type是float</span></span><br></pre></td></tr></table></figure>

<h3 id="2-类模板——class-tmeplate"><a href="#2-类模板——class-tmeplate" class="headerlink" title="2_类模板——class tmeplate"></a>2_类模板——class tmeplate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一种模板用来做出类，类模板里的每一个函数都是函数模板</span></span><br><span class="line">例子：</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;	<span class="comment">//同函数模板，关键字和占位类型（占位类型可以有多个如：template&lt; class key, class value&gt; ，逗号隔开即可），表示下面的东西是template，Vector是一个声明</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Vector</span> &#123;	<span class="comment">//和正常类一样，Vector是名字</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Vector</span>(<span class="type">int</span>);	<span class="comment">//构造函数，参数为int</span></span><br><span class="line">		~<span class="built_in">Vector</span>();	<span class="comment">//析构函数</span></span><br><span class="line">		<span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp;);<span class="comment">//拷贝构造函数</span></span><br><span class="line">		Vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp;);	<span class="comment">//赋值运算符重载</span></span><br><span class="line">		T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>);	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T* m_elements;</span><br><span class="line">		<span class="type">int</span> m_size;</span><br><span class="line">	&#125;</span><br><span class="line">注<span class="number">5</span>：使用Vector时因为表示传参数，所以得像 注<span class="number">4</span> 那样显示地指明 T 的type，如：<span class="function">Vector&lt;<span class="type">int</span>&gt; <span class="title">i</span><span class="params">(<span class="number">100</span>)</span></span>;	<span class="comment">//通过参数为int类型的构造函数创建一个Vector对象，且 T 的类型是int</span></span><br><span class="line"></span><br><span class="line">注<span class="number">6</span>：类模板中的类的函数，都得写成函数模板的格式（其实也就是在类成员函数的定义前加上 <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> &gt;，然后按需求把某些变量类型改成 T ，类名后和域解析符前得加上 &lt;T&gt; ）如：</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;	<span class="comment">//不能省</span></span><br><span class="line">	Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">int</span> size) : <span class="built_in">m_size</span>(size) &#123; <span class="comment">//参数为int的构造函数的定义，注意Vector&lt;T&gt;，中&lt;T&gt;不能省</span></span><br><span class="line">		m_elements = <span class="keyword">new</span> T[m_size];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;	<span class="comment">//不能省</span></span><br><span class="line">	T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[] (<span class="type">int</span> indx)	&#123; <span class="comment">//赋值运算符重载函数的定义，注意Vector&lt;T&gt;，中&lt;T&gt;不能省</span></span><br><span class="line">		<span class="keyword">if</span> (indx &lt; m_size &amp;&amp; indx &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> m_elements[indx];</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">注<span class="number">7</span>：如果出现Vector&lt; Vector &lt; <span class="type">double</span> *&gt; &gt;;（即有一个Vector它的每一个单元都是一个Vector，而那个Vector的每一个单元都是一个<span class="type">double</span> *）这种要注意，最后面的两个&gt;，有些编译器要中间加一个空格，否则会识别为右移或者流</span><br><span class="line">    </span><br><span class="line">注<span class="number">8</span>：模板函数的占位类型实际可以非常复杂如：</span><br><span class="line">    Vector&lt; <span class="built_in">int</span> (*) (Vector&lt;<span class="type">double</span>&gt;&amp;,<span class="type">int</span>) &gt;;（一个Vector它的每一个单元都是一个函数指针，该函数指针指向的函数的参数有两项，第一项是一个每一个单元都是<span class="type">double</span>的Vector而且是通过引用传递，第二项是一个<span class="type">int</span>）</span><br></pre></td></tr></table></figure>

<h3 id="3-模板函数——template-function"><a href="#3-模板函数——template-function" class="headerlink" title="3_模板函数——template function"></a>3_模板函数——template function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是由模板生成的函数</span><br></pre></td></tr></table></figure>

<h3 id="4-模板类——template-class"><a href="#4-模板类——template-class" class="headerlink" title="4_模板类——template class"></a>4_模板类——template class</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是由模板生成的类</span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-特别注意-1-x3D-x3D"><a href="#x3D-x3D-特别注意-1-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;特别注意_1&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意_1&#x3D;&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">模板<span class="keyword">template</span>的参数不仅可以是一种未指定类型（占位类型），也可以是实际类型（甚至可以给其设置缺省值）</span><br><span class="line">如：</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> bounds = <span class="number">100</span>&gt; <span class="comment">//bounds是一个带缺省值的变量，且在模板里面可以直接使用</span></span><br><span class="line">	<span class="keyword">class</span> FixedVector &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">FixedVector</span>();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>);</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T elements[bounds];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FixedVector&lt;<span class="type">int</span>, <span class="number">50</span>&gt; v1; 	<span class="comment">//种50个int</span></span><br><span class="line">	FixedVector&lt;<span class="type">int</span>, <span class="number">10</span>*<span class="number">5</span>&gt; v2;	<span class="comment">//种50个int</span></span><br><span class="line">	FixedVector&lt;<span class="type">int</span>&gt; v3;		<span class="comment">//种100个int</span></span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-特别注意-2-x3D-x3D"><a href="#x3D-x3D-特别注意-2-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;特别注意_2&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意_2&#x3D;&#x3D;</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>	template和template之间不能做继承，</span><br><span class="line"><span class="bullet">2.</span>	template可以继承于一个non-template的类</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span>	non-template类也可以继承template类（实际是先种出一个模板类再把这个模板类继承给那个non-template类）如：</span><br><span class="line"><span class="code">	class SupervisorGroup : public List&lt;Employee*&gt;&#123;...&#125; //List是一个类模板，这里指定了占位类型为Employee *</span></span><br></pre></td></tr></table></figure>



<h2 id="基础概念-15——异常——exception"><a href="#基础概念-15——异常——exception" class="headerlink" title="基础概念_15——异常——exception"></a>基础概念_15——异常——exception</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">	运行到某处时，有问题出现，但当前环境或程序或函数无法处理，以至于无法继续下去的情况就叫exception，但在某处，某个程序或函数可以处理</span><br><span class="line"></span><br><span class="line">关键字：</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		code;						<span class="comment">//catch中也可以throw异常</span></span><br><span class="line">	&#125; <span class="built_in">catch</span> ( error_type )&#123;			<span class="comment">// error_type 是 ... 时表示捕获所有类型的异常</span></span><br><span class="line">		code;						<span class="comment">//catch中也可以throw异常</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> error_type;	<span class="comment">//向上抛异常并退出当前函数，直到遇到有catch能捕获抛出的异常时停止</span></span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> block</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        code_1;								<span class="comment">//尝试做一些可能会导致异常的代码</span></span><br><span class="line">    &#125;<span class="built_in">catch</span> (error_type_1 var_name)&#123;			<span class="comment">//error_type_1 var_name可以理解成函数的形参表，且var_name变量在对应的code中可以使用，其实catch就像一个处理函数</span></span><br><span class="line">    	code_2;</span><br><span class="line">    &#125;<span class="built_in">catch</span> (error_type_2 var_name)&#123;			<span class="comment">//针对error_type的子类，会执行类型转换（upcast，向上造型），即子类的捕获要放在父类捕获前，否则该子类catch永远无法执行，编译无法通过</span></span><br><span class="line">        code_3;</span><br><span class="line">    &#125;									<span class="comment">//catch查找是按从上到下的顺序查找的，如果catch(...)是第一个catch则其后的catch全部永远没法执行，编译无法通过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">特色操作：</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> : throw(error_type_1, error_type_2)&#123;</span>	<span class="comment">//c++函数后面这样写，代表该函数在运行时最多可能会抛出这些异常，这样写后func只能抛出error_type_1和error_type_2两种异常，抛其他异常，系统反而会抛异常</span></span><br><span class="line">    	code;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//一个函数后面不这样写，则可以抛出任何异常。如果是throw()，括号里面不写类型则意味着该函数不会抛出任何异常</span></span><br><span class="line"></span><br><span class="line">注：c中malloc失败时会返回一个null，但在c++中不会，只会抛一个bad_malloc异常</span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-特别注意-x3D-x3D-4"><a href="#x3D-x3D-特别注意-x3D-x3D-4" class="headerlink" title="&#x3D;&#x3D;特别注意&#x3D;&#x3D;"></a>&#x3D;&#x3D;特别注意&#x3D;&#x3D;</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数中如果使用抛异常来通知构造失败的话（因为构造函数和析构函数没有返回值），可能会导致奇奇怪怪的问题，因为如果构造函数使用到了new，但构造没成功，抛了异常，那么new来的空间就变成垃圾内存了</span><br></pre></td></tr></table></figure>



<h2 id="基础概念-16——流——stream"><a href="#基础概念-16——流——stream" class="headerlink" title="基础概念_16——流——stream"></a>基础概念_16——流——stream</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">流——单方向</span><br><span class="line">c和c++对文件操作的区别：</span><br><span class="line"><span class="code">	c语言中，对一个文件可以任意的游走（random access），从第一段开始读，从第25段的第34个字符开始读。而c++的流是单方向的，“流”过去了，就没有了</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">流操作——Stream operations</span><br><span class="line"><span class="bullet">1.</span>	Extractors —— &gt;&gt; 从流里面读东西（已经被重载，根据左边的receiver不同调用的不同，如果receiver是istream则是extractor，receiver如果是一个int则是右移）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span>	Inserters —— &lt;&lt; 向流里面写东西（同上）</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span>	Manipulators —— 操控流的怎么读，怎么写（类似格式化输入输出）</span><br><span class="line"></span><br><span class="line">流的类型——Stream type</span><br><span class="line"><span class="bullet">1.</span>	Text streams</span><br><span class="line"><span class="code">	文本流，parse和format，解析和格式化</span></span><br><span class="line"><span class="code">2.	Binary streams</span></span><br><span class="line"><span class="code">	二进制数据，</span></span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	istream &gt;&gt; lvalue</span><br><span class="line">	会根据lvalue的变量类型，自动解析怎么把值传给lvalue</span><br><span class="line">注<span class="number">1</span>：自动解析的类型：</span><br><span class="line">	<span class="type">char</span>		%c</span><br><span class="line">	<span class="type">short</span>, <span class="type">int</span>	%d</span><br><span class="line">	<span class="type">long</span>		%ld</span><br><span class="line">	<span class="type">float</span>		%g</span><br><span class="line">	<span class="type">double</span>		%lg</span><br><span class="line">	<span class="type">long</span> <span class="type">double</span>	%Lg</span><br><span class="line">	<span class="type">char</span> *		%s</span><br><span class="line">	<span class="type">void</span> *		%p</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>	手动重载 &gt;&gt; 运算符</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, T&amp; obj)&#123;	<span class="comment">//第一个参数（也就是receiver），istream&amp;之所以不加const是因为要修改流</span></span><br><span class="line">	code;		<span class="comment">//读取流操作</span></span><br><span class="line">	<span class="keyword">return</span> is;	<span class="comment">//返回类型也是istream&amp; 是操作流之后可以把操作完后的流继续操作，如：( ( cin&gt;&gt;a )&gt;&gt;b )&gt;&gt;c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>	手动重载 &lt;&lt; 运算符</span><br><span class="line">    ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> T&amp; obj)&#123;</span><br><span class="line">    	code;		<span class="comment">//实际插入流操作</span></span><br><span class="line">    	<span class="keyword">return</span> os;		<span class="comment">//	( ( cout&lt;&lt;a )&lt;&lt;b )&lt;&lt;c，返回的是ostream&amp;的原因</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">4.</span>	常见使用</span><br><span class="line">    ch = cin.<span class="built_in">get</span>();	读一个字符，如果读完了则返回EOF</span><br><span class="line">    cout.<span class="built_in">put</span>(ch);	<span class="comment">// 打印一个字符</span></span><br><span class="line">    <span class="built_in">ignore</span>(<span class="type">int</span> limit = <span class="number">1</span>, <span class="type">int</span> delim = EOF);	跳过多少个东西不读，一直读到什么位置，这里缺省值是跳过一个，一直读到结束</span><br><span class="line">    cout.<span class="built_in">flush</span>();	<span class="comment">//强制输出流的内容到物理介质上去</span></span><br><span class="line"><span class="number">5.</span>	manipulator，格式化	<span class="comment">//要导入头文件iomanip</span></span><br><span class="line">    endl其实是个manipulator</span><br><span class="line">    <span class="comment">//例子</span></span><br><span class="line">    cin &gt;&gt; hex &gt;&gt; n;	<span class="comment">//以十六进制输入给n</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="number">1000.243</span> &lt;&lt; endl;	<span class="comment">//按两位小数输出</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; <span class="string">&quot;OK!&quot;</span>;	<span class="comment">//占20位，输出右对齐</span></span><br><span class="line"><span class="number">6.</span>	常见manipulators:</span><br><span class="line">	dec, hex, otc	数字进制转化						   		 			I,O</span><br><span class="line">    endl			插入一个新行，并使用flush				 					 O</span><br><span class="line">	flush			flush流（相当于刷新缓冲区）								<span class="function">O</span></span><br><span class="line"><span class="function">	<span class="title">setw</span><span class="params">(<span class="type">int</span>)</span>		设置占位宽度（最小要这么宽，宽度大于设定则不管）			I, O</span></span><br><span class="line"><span class="function">	<span class="title">setfill</span><span class="params">(ch)</span>		如果输出的东西没有设定的那么宽，则用什么填充				 I, O</span></span><br><span class="line"><span class="function">	<span class="title">setbase</span><span class="params">(<span class="type">int</span>)</span>	相当于进制拓展，可以设定以任意进制输出						   O</span></span><br><span class="line"><span class="function">	ws					跳过空格											I</span></span><br><span class="line"><span class="function">	<span class="title">setprecision</span><span class="params">(<span class="type">int</span>)</span>	设置精度，即多少位小数									O</span></span><br><span class="line"><span class="function">	<span class="title">setiosflags</span><span class="params">(<span class="type">long</span>)</span>	设置流里面都是ON，相当于1							I, O</span></span><br><span class="line"><span class="function">	<span class="title">resetiosflags</span><span class="params">(<span class="type">long</span>)</span>	设置流里面都是OFF，相当于0							I, O</span></span><br><span class="line"><span class="function">7.	预定义流</span></span><br><span class="line"><span class="function">        cin			standard input</span></span><br><span class="line"><span class="function">        cout		standard output</span></span><br><span class="line"><span class="function">        cerr		unbuffered <span class="title">error</span><span class="params">(debugging)</span> output</span></span><br><span class="line"><span class="function">        clog		buffered <span class="title">error</span><span class="params">(debugging)</span> output</span></span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-自定义Manipulator-与-IOS-flag-x3D-x3D"><a href="#x3D-x3D-自定义Manipulator-与-IOS-flag-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;自定义Manipulator 与 IOS flag&#x3D;&#x3D;"></a>&#x3D;&#x3D;自定义Manipulator 与 IOS flag&#x3D;&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>	Manipulator</span><br><span class="line"><span class="comment">//这是全局函数</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">manip</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">    code;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">tab</span><span class="params">(ostream&amp; out)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> out &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;		<span class="comment">//返回一个ostream的引用，且返回时还有一个 &lt;&lt; 的调用，把&#x27;\t&#x27;插入到流中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; tab &lt;&lt; <span class="string">&quot;World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ios :: flag	标志</span><br><span class="line">    ios::skipws							<span class="comment">//忽略前导空格</span></span><br><span class="line">    ios::lef, ios::right				<span class="comment">//设置左对齐，右对齐</span></span><br><span class="line">    ios::internal						<span class="comment">//数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</span></span><br><span class="line">    ios::dec, ios::oct, ios::hex		<span class="comment">//设置整数的基数为10，8，16</span></span><br><span class="line">    ios::showbase						<span class="comment">//强制输出整数的基数(八进制数以0打头，十六进制数以0x打头)</span></span><br><span class="line">    ios::showpoint						<span class="comment">//强制显示小数点</span></span><br><span class="line">    ios::uppercase						<span class="comment">//16进制数大写输出</span></span><br><span class="line">    ios::showpos						<span class="comment">//强制显示符号</span></span><br><span class="line">    ios::scientific, ios::fixed			<span class="comment">//设置指数显示，固定浮点显示</span></span><br><span class="line">    ios::unitbuf						<span class="comment">//每次输出后刷新所有的流</span></span><br><span class="line">    ios::boolalpha 						<span class="comment">//以“true”/“false”的形式输出布尔值</span></span><br><span class="line">    ios::stdio 							<span class="comment">//每次输出之后清除stdout, stderr</span></span><br><span class="line">   	<span class="comment">//使用方法</span></span><br><span class="line">    <span class="number">2.1</span>		使用<span class="function">Manipulator</span></span><br><span class="line"><span class="function">    	<span class="title">setiosflags</span><span class="params">(flags)</span></span>;				<span class="comment">//flags 就是上面的代码，如ios::skipws</span></span><br><span class="line">    	<span class="built_in">resetiosflags</span>(flags);</span><br><span class="line">	<span class="number">2.2</span>		使用stream成员函数</span><br><span class="line">        istream.<span class="built_in">setf</span>(flags);					<span class="comment">//flags 同理，istream是cin或cout这种流对象</span></span><br><span class="line">        istream.<span class="built_in">unsetf</span>(flags);</span><br></pre></td></tr></table></figure>



<h2 id="基础概念-17——STL——Standard-Library"><a href="#基础概念-17——STL——Standard-Library" class="headerlink" title="基础概念_17——STL——Standard Library"></a>基础概念_17——STL——Standard Library</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>	容器——Containers（注意在使用时所有的容器都是小写，实际上就是类模板）</span><br><span class="line"><span class="code">	Vector		一个可以在后面（一个方向）增长的数组</span></span><br><span class="line"><span class="code">	Deque		一个可以在前后都可以增长的数组</span></span><br><span class="line"><span class="code">	List		双向链表</span></span><br><span class="line"><span class="code">	Sets		集合（没有重复的元素）</span></span><br><span class="line"><span class="code">	Map			映射，键值对</span></span><br><span class="line"><span class="code">	Pair		表达两东西之间的关系，这两东西可以是任何东西</span></span><br><span class="line"><span class="code">2.	基础算法——Basic Algorithms（实际上是一些函数模板）</span></span><br><span class="line"><span class="code">	sort		排序</span></span><br><span class="line"><span class="code">	search		查找</span></span><br><span class="line"><span class="code">	...</span></span><br><span class="line"><span class="code">3.	迭代器——Iterators</span></span><br><span class="line"><span class="code">	如：</span></span><br><span class="line"><span class="code">		vector&lt;int&gt;::iterator p;	//p是vector&lt;int&gt;这个类里面的类叫iterator的对象</span></span><br><span class="line"><span class="code">		p = x.begin();				//p现在用来代表x中的第一个元素</span></span><br><span class="line"><span class="code">		cout &lt;&lt; *p &lt;&lt; endl;			//*是被重载了的，vector&lt;in&gt;说明p是一个int，所以*p是一个int</span></span><br><span class="line"><span class="code">		p++;						//++也是被重载过的</span></span><br><span class="line"><span class="code">4.	所有STL的东西都是在 std 那个命名空间中，所以得使用using namespace std;否则用一个就得加 std::</span></span><br></pre></td></tr></table></figure>















<h2 id="类-例子"><a href="#类-例子" class="headerlink" title="类_例子"></a>类_例子</h2><h4 id="售票机类"><a href="#售票机类" class="headerlink" title="售票机类"></a>售票机类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TicketMachine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPrompt</span><span class="params">()</span></span>;	<span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMoney</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTicket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBalance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printError</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> PRICE;	<span class="comment">//成员变量</span></span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="检验代码"><a href="#检验代码" class="headerlink" title="检验代码"></a>检验代码</h2><h4 id="分析类不同实例的成员变量值-x3D-x3D-检验代码-1-x3D-x3D"><a href="#分析类不同实例的成员变量值-x3D-x3D-检验代码-1-x3D-x3D" class="headerlink" title="分析类不同实例的成员变量值			&#x3D;&#x3D;检验代码_1&#x3D;&#x3D;"></a>分析类不同实例的成员变量值			&#x3D;&#x3D;检验代码_1&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	A b;</span><br><span class="line">	b.i = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i_1 = &quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line">	a.i = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a.i_1 = &quot;</span> &lt;&lt; a.i &lt;&lt; endl;</span><br><span class="line">	a.<span class="built_in">f</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i_2 = &quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a.i_2 = &quot;</span> &lt;&lt; a.i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.i_1 = <span class="number">30</span></span><br><span class="line">a.i_1 = <span class="number">10</span></span><br><span class="line">b.i_2 = <span class="number">30</span></span><br><span class="line">a.i_2 = <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h4 id="探究c-对象实质-x3D-x3D-检验代码-2-x3D-x3D"><a href="#探究c-对象实质-x3D-x3D-检验代码-2-x3D-x3D" class="headerlink" title="探究c++对象实质			&#x3D;&#x3D;检验代码_2&#x3D;&#x3D;"></a>探究c++对象实质			&#x3D;&#x3D;检验代码_2&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::f()--&amp;i = &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;a = &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;a.i = &quot;</span> &lt;&lt; &amp;(a.i) &lt;&lt; endl;</span><br><span class="line">	a.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;a = <span class="number">0x61fe1c</span></span><br><span class="line">&amp;a.i = <span class="number">0x61fe1c</span></span><br><span class="line">A::<span class="built_in">f</span>()--&amp;i = <span class="number">0x61fe1c</span></span><br></pre></td></tr></table></figure>



<h4 id="解密new与delete测试1不带-x3D-x3D-检验代码-3-x3D-x3D"><a href="#解密new与delete测试1不带-x3D-x3D-检验代码-3-x3D-x3D" class="headerlink" title="解密new与delete	测试1	不带[]		&#x3D;&#x3D;检验代码_3&#x3D;&#x3D;"></a>解密new与delete	测试1	不带[]		&#x3D;&#x3D;检验代码_3&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;i = <span class="number">0</span>;cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(), i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i].<span class="built_in">set</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="解密new与delete测试2带-x3D-x3D-检验代码-4-x3D-x3D"><a href="#解密new与delete测试2带-x3D-x3D-检验代码-4-x3D-x3D" class="headerlink" title="解密new与delete	测试2	带[]	&#x3D;&#x3D;检验代码_4&#x3D;&#x3D;"></a>解密new与delete	测试2	带[]	&#x3D;&#x3D;检验代码_4&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;i = <span class="number">0</span>;cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(), i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		p[i].<span class="built_in">set</span>(i);</span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">9</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">8</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">7</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">6</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">5</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">4</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">3</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">2</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">1</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="解密new与delete-x3D-x3D-检验代码-5-x3D-x3D"><a href="#解密new与delete-x3D-x3D-检验代码-5-x3D-x3D" class="headerlink" title="解密new与delete				&#x3D;&#x3D;检验代码_5&#x3D;&#x3D;"></a>解密new与delete				&#x3D;&#x3D;检验代码_5&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;i = <span class="number">0</span>;cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(), i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A *q)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::g(), q-&gt;i=&quot;</span> &lt;&lt; q-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">	A b;</span><br><span class="line">	b.<span class="built_in">set</span>(<span class="number">1000</span>);</span><br><span class="line">	a.<span class="built_in">g</span>(&amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">g</span>(), q-&gt;i=<span class="number">1000</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">1000</span></span><br><span class="line">A::~<span class="built_in">A</span>(), i = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="继承初体验-x3D-x3D-检验代码-6-x3D-x3D"><a href="#继承初体验-x3D-x3D-检验代码-6-x3D-x3D" class="headerlink" title="继承初体验				&#x3D;&#x3D;检验代码_6&#x3D;&#x3D;"></a>继承初体验				&#x3D;&#x3D;检验代码_6&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">	b.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">A::<span class="built_in">f</span>()i=<span class="number">100</span></span><br><span class="line">A::~<span class="built_in">A</span>()</span><br></pre></td></tr></table></figure>



<h4 id="继承再体验-x3D-x3D-检验代码-7-x3D-x3D"><a href="#继承再体验-x3D-x3D-检验代码-7-x3D-x3D" class="headerlink" title="继承再体验				&#x3D;&#x3D;检验代码_7&#x3D;&#x3D;"></a>继承再体验				&#x3D;&#x3D;检验代码_7&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> ii) : <span class="built_in">i</span>(ii) &#123;&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::print() i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">A</span>(<span class="number">15</span>) &#123; cout &lt;&lt; <span class="string">&quot;B::B() &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.<span class="built_in">set</span>(<span class="number">66</span>);</span><br><span class="line">	b.<span class="built_in">f</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B::<span class="built_in">B</span>()</span><br><span class="line">A::<span class="built_in">print</span>() i = <span class="number">2</span></span><br><span class="line">B::~<span class="built_in">B</span>()</span><br><span class="line">A::~<span class="built_in">A</span>()</span><br></pre></td></tr></table></figure>



<h4 id="c-名字隐藏-x3D-x3D-检验代码-8-x3D-x3D"><a href="#c-名字隐藏-x3D-x3D-检验代码-8-x3D-x3D" class="headerlink" title="c++名字隐藏				&#x3D;&#x3D;检验代码_8&#x3D;&#x3D;"></a>c++名字隐藏				&#x3D;&#x3D;检验代码_8&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::print() i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125; <span class="comment">//A类中print有重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::print(int ii) &quot;</span> &lt;&lt; ii &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::B() &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::print()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.<span class="built_in">print</span>();			<span class="comment">//使用B类自己的print函数</span></span><br><span class="line">	b.A::<span class="built_in">print</span>(<span class="number">1234</span>);	<span class="comment">//使用A类的那个print函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>()</span><br><span class="line">B::<span class="built_in">B</span>()</span><br><span class="line">B::<span class="built_in">print</span>()</span><br><span class="line">A::<span class="built_in">print</span>(<span class="type">int</span> ii) <span class="number">1234</span></span><br><span class="line">B::~<span class="built_in">B</span>()</span><br><span class="line">A::~<span class="built_in">A</span>()</span><br></pre></td></tr></table></figure>



<h3 id="C-重载-x3D-x3D-检验代码-9-x3D-x3D"><a href="#C-重载-x3D-x3D-检验代码-9-x3D-x3D" class="headerlink" title="C++重载				&#x3D;&#x3D;检验代码_9&#x3D;&#x3D;"></a>C++重载				&#x3D;&#x3D;检验代码_9&#x3D;&#x3D;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code.h文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j=<span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="comment">//code.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;code.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;code.cpp::func &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;code.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">29</span>);</span><br><span class="line">        <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译时用 g++ code.cpp main.cpp -o main.exe</span></span><br></pre></td></tr></table></figure>

<h3 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code.cpp::func <span class="number">1</span>:<span class="number">29</span></span><br><span class="line">code.cpp::func <span class="number">5</span>:<span class="number">8</span></span><br></pre></td></tr></table></figure>



<h4 id="C-缺省声明探究-x3D-x3D-检验代码-10-x3D-x3D"><a href="#C-缺省声明探究-x3D-x3D-检验代码-10-x3D-x3D" class="headerlink" title="C++缺省声明探究				&#x3D;&#x3D;检验代码_10&#x3D;&#x3D;"></a>C++缺省声明探究				&#x3D;&#x3D;检验代码_10&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i=<span class="number">111</span>, <span class="type">int</span> j=<span class="number">111</span>)</span></span>;	<span class="comment">//定义文件中的声明，此处声明不会生效，或者说会被覆盖</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;code.cpp::func &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.cpp文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j=<span class="number">123</span>)</span></span>;	<span class="comment">//调用func函数的文件中的声明，会失效</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译时用 g++ code.cpp main.cpp	会默认生成a.exe (windows下)</span></span><br></pre></td></tr></table></figure>

<h4 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code.cpp::func <span class="number">5</span>:<span class="number">123</span></span><br></pre></td></tr></table></figure>



<h4 id="C-其他编译单元调用内联函数-x3D-x3D-检验代码-11-x3D-x3D"><a href="#C-其他编译单元调用内联函数-x3D-x3D-检验代码-11-x3D-x3D" class="headerlink" title="C++其他编译单元调用内联函数				&#x3D;&#x3D;检验代码_11&#x3D;&#x3D;"></a>C++其他编译单元调用内联函数				&#x3D;&#x3D;检验代码_11&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;code.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//code.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j = <span class="number">19</span>)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译时用 g++ main.cpp</span></span><br></pre></td></tr></table></figure>

<h4 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span> j = <span class="number">19</span></span><br></pre></td></tr></table></figure>



<h4 id="C-const运用-x3D-x3D-检验代码-12-x3D-x3D"><a href="#C-const运用-x3D-x3D-检验代码-12-x3D-x3D" class="headerlink" title="C++ const运用				&#x3D;&#x3D;检验代码_12&#x3D;&#x3D;"></a>C++ const运用				&#x3D;&#x3D;检验代码_12&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="type">char</span> s2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 =   %p\n&quot;</span>, s1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s2 =   %p\n&quot;</span>, s2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main = %p\n&quot;</span>, main);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 =   <span class="number">0000000000404000</span></span><br><span class="line">s2 =   <span class="number">000000000061F</span>E0C</span><br><span class="line">main = <span class="number">0000000000401550</span></span><br></pre></td></tr></table></figure>



<h4 id="C-const运用-2-x3D-x3D-检验代码-13-x3D-x3D"><a href="#C-const运用-2-x3D-x3D-检验代码-13-x3D-x3D" class="headerlink" title="C++ const运用_2				&#x3D;&#x3D;检验代码_13&#x3D;&#x3D;"></a>C++ const运用_2				&#x3D;&#x3D;检验代码_13&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;f() const&quot;</span> &lt;&lt; endl; &#125; <span class="comment">//这两f函数的默认参数this不一样，一个带有const关键字，一个没有，所以可实现重载</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> A a;	<span class="comment">//a是有const关键字的对象</span></span><br><span class="line">    a.<span class="built_in">f</span>();		<span class="comment">//调用的是带const关键字的f函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>() <span class="type">const</span></span><br></pre></td></tr></table></figure>



<h4 id="C-conversion-x3D-x3D-检验代码-14-x3D-x3D"><a href="#C-conversion-x3D-x3D-检验代码-14-x3D-x3D" class="headerlink" title="C++ conversion				&#x3D;&#x3D;检验代码_14&#x3D;&#x3D;"></a>C++ conversion				&#x3D;&#x3D;检验代码_14&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; A.i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125; <span class="comment">// A类中的print函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123; <span class="comment">// B类继承于A类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">j</span>(<span class="number">4</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; B.j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125; <span class="comment">// B类中的print函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    b.<span class="built_in">print</span>();          <span class="comment">//调用的是B类的成员函数print</span></span><br><span class="line">    b.A::<span class="built_in">print</span>();       <span class="comment">//调用的是A类的成员函数print</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a; <span class="comment">//这里的&amp;是取地址，不是引用，取a对象的地址，并转换为int类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p;</span><br><span class="line">    *p = <span class="number">20</span>; <span class="comment">//取了地址后，直接通过地址改变private属性的成员变量的值</span></span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    p = (<span class="type">int</span> *)&amp;b; <span class="comment">//取对象b的地址，该地址如果是int型指针则正好可以控制A类中的i，即子类中的第一个成员变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    *p = <span class="number">123</span>; <span class="comment">//肆意改动对象b的private成员变量的值</span></span><br><span class="line">    p++;      <span class="comment">// p是int型指针，++后可以控制对象b中的j</span></span><br><span class="line">    *p = <span class="number">2333</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p;</span><br><span class="line">    b.A::<span class="built_in">print</span>(); <span class="comment">//输出i</span></span><br><span class="line">    b.<span class="built_in">print</span>();    <span class="comment">//输出j</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-13"><a href="#输出-13" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> A.i = <span class="number">1</span></span><br><span class="line"> B.j = <span class="number">4</span></span><br><span class="line"> A.i = <span class="number">1</span></span><br><span class="line">p = <span class="number">0x61fe04</span> A.i = <span class="number">20</span></span><br><span class="line">p = <span class="number">0x61fdfc</span> A.i = <span class="number">20</span></span><br><span class="line">p = <span class="number">0x61fe00</span> A.i = <span class="number">123</span></span><br><span class="line"> B.j = <span class="number">2333</span></span><br></pre></td></tr></table></figure>



<h4 id="C-virtual关键字-x3D-x3D-检验代码-15-x3D-x3D"><a href="#C-virtual关键字-x3D-x3D-检验代码-15-x3D-x3D" class="headerlink" title="C++ virtual关键字				&#x3D;&#x3D;检验代码_15&#x3D;&#x3D;"></a>C++ virtual关键字				&#x3D;&#x3D;检验代码_15&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">123</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(a) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;<span class="comment">//输出对象a的大小</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line">    <span class="type">int</span> *q = (<span class="type">int</span> *)&amp;b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;q,*q = &quot;</span> &lt;&lt; *q &lt;&lt; endl;	<span class="comment">//输出对象a的vtpr指针</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p,*P = &quot;</span> &lt;&lt; *p &lt;&lt; endl;	<span class="comment">//输出对象b的vtpr指针</span></span><br><span class="line">    p++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p+1,*P = &quot;</span> &lt;&lt; *p &lt;&lt; endl;	<span class="comment">//不知道输出了什么玩意的值</span></span><br><span class="line">    p++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p+2,*P = &quot;</span> &lt;&lt; *p &lt;&lt; endl;	<span class="comment">//输出对现象a中的i的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-14"><a href="#输出-14" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">f</span>()</span><br><span class="line"><span class="built_in">sizeof</span>(a) = <span class="number">16</span></span><br><span class="line">q,*q = <span class="number">4212016</span></span><br><span class="line">p,*P = <span class="number">4212016</span></span><br><span class="line">p+<span class="number">1</span>,*P = <span class="number">0</span></span><br><span class="line">p+<span class="number">2</span>,*P = <span class="number">123</span></span><br></pre></td></tr></table></figure>



<h4 id="C-魔改vtpr-x3D-x3D-检验代码-16-x3D-x3D"><a href="#C-魔改vtpr-x3D-x3D-检验代码-16-x3D-x3D" class="headerlink" title="C++ 魔改vtpr				&#x3D;&#x3D;检验代码_16&#x3D;&#x3D;"></a>C++ 魔改vtpr				&#x3D;&#x3D;检验代码_16&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>		<span class="comment">//父类A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">123</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A		<span class="comment">//子类B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">j</span>(<span class="number">888</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f() i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line">    <span class="type">int</span> *q = (<span class="type">int</span> *)&amp;b;</span><br><span class="line">    A *aa = &amp;a;</span><br><span class="line">    B *bb = &amp;b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object a : &quot;</span> &lt;&lt; endl;	<span class="comment">//输出父类A的对象a的成员函数f</span></span><br><span class="line">    aa-&gt;<span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object b : &quot;</span> &lt;&lt; endl;	<span class="comment">//输出子类B的对象b的成员函数f</span></span><br><span class="line">    bb-&gt;<span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b.vtpr to a.vtpr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object a : &quot;</span> &lt;&lt; endl;</span><br><span class="line">    *p = *q;	<span class="comment">//把子类对象b的vtpr指针赋值给了父类对象a的vtpr指针</span></span><br><span class="line">    aa-&gt;<span class="built_in">f</span>();	<span class="comment">//此时父类对象a的vtpr已经指向了子类的vtable了所以调用的是子类的虚函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-15"><a href="#输出-15" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">object a :</span><br><span class="line">A::<span class="built_in">f</span>() i = <span class="number">123</span></span><br><span class="line">object b :</span><br><span class="line">B::<span class="built_in">f</span>() i = <span class="number">123</span> j = <span class="number">888</span></span><br><span class="line">b.vtpr to a.vtpr</span><br><span class="line">object a :</span><br><span class="line">B::<span class="built_in">f</span>() i = <span class="number">123</span> j = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="C-覆写-x3D-x3D-检验代码-17-x3D-x3D"><a href="#C-覆写-x3D-x3D-检验代码-17-x3D-x3D" class="headerlink" title="C++ 覆写				&#x3D;&#x3D;检验代码_17&#x3D;&#x3D;"></a>C++ 覆写				&#x3D;&#x3D;检验代码_17&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A() : i(123) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; cout &lt;&lt; &quot;A::f() i = &quot; &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int j;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    B() : j(888) &#123;&#125;</span><br><span class="line">    virtual void f() &#123; A::f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.f();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-16"><a href="#输出-16" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::f() i = 123</span><br></pre></td></tr></table></figure>



<h4 id="C-引用再体验-x3D-x3D-检验代码-18-x3D-x3D"><a href="#C-引用再体验-x3D-x3D-检验代码-18-x3D-x3D" class="headerlink" title="C++ 引用再体验				&#x3D;&#x3D;检验代码_18&#x3D;&#x3D;"></a>C++ 引用再体验				&#x3D;&#x3D;检验代码_18&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> array[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arry[3] = &quot;</span> &lt;&lt; array[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">func</span>(<span class="number">3</span>) = <span class="number">24</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arry[3] = &quot;</span> &lt;&lt; array[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-17"><a href="#输出-17" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arry[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">arry[<span class="number">3</span>] = <span class="number">24</span></span><br></pre></td></tr></table></figure>



<h4 id="C-匿名变量-x3D-x3D-检验代码-19-x3D-x3D"><a href="#C-匿名变量-x3D-x3D-检验代码-19-x3D-x3D" class="headerlink" title="C++ 匿名变量				&#x3D;&#x3D;检验代码_19&#x3D;&#x3D;"></a>C++ 匿名变量				&#x3D;&#x3D;检验代码_19&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">f</span>(i * <span class="number">3</span>);		<span class="comment">//系统会自动创建一个匿名变量来保存这个运算的值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-18"><a href="#输出-18" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>



<h4 id="C-静态成员变量-x3D-x3D-检验代码-20-x3D-x3D"><a href="#C-静态成员变量-x3D-x3D-检验代码-20-x3D-x3D" class="headerlink" title="C++ 静态成员变量				&#x3D;&#x3D;检验代码_20&#x3D;&#x3D;"></a>C++ 静态成员变量				&#x3D;&#x3D;检验代码_20&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;i = <span class="number">10</span>;&#125;	<span class="comment">//这句只是赋值，不是初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::i;	<span class="comment">// A类中的静态成员i的定义也是初始化（只是没有赋初值）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a, b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">123</span>);</span><br><span class="line">    b.<span class="built_in">f</span>();		<span class="comment">//如果i是public的，还可以直接b.i或者A::i来访问i都一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-19"><a href="#输出-19" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">f</span>() i = <span class="number">123</span></span><br></pre></td></tr></table></figure>



<h4 id="C-自动类型转换-x3D-x3D-检验代码-21-x3D-x3D"><a href="#C-自动类型转换-x3D-x3D-检验代码-21-x3D-x3D" class="headerlink" title="C++ 自动类型转换				&#x3D;&#x3D;检验代码_21&#x3D;&#x3D;"></a>C++ 自动类型转换				&#x3D;&#x3D;检验代码_21&#x3D;&#x3D;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;	<span class="comment">//B类的前项声明，免得因为B类写在A类后面导致编译器找不到B类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//在这个构造函数前加上关键字explicit后，将使该函数不能用于自动类型转换，然后报错</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B &amp;b) &#123; cout &lt;&lt; <span class="string">&quot;A::A(const b &amp;b)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// A类有一个可以通过B类对象构造自身对象的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a)</span> <span class="comment">// f函数需要一个A类的对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">f</span>(b); <span class="comment">//给f函数传一个B类的对象b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-20"><a href="#输出-20" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> b &amp;b)	<span class="comment">//默认调用的了A那个构造函数先通过B类的对象构造处一个匿名的A类的对象再传给f函数</span></span><br><span class="line"><span class="built_in">f</span>()</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mq.cq.cn">MaQiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mq.cq.cn/2022/04/24/C++%E5%9F%BA%E7%A1%80/">http://mq.cq.cn/2022/04/24/C++%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mq.cq.cn" target="_blank">Makima</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/02/24/zT4VKe6ECMLfghY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/12/VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="VSCode环境配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">VSCode环境配置</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/24/TDD/" title="TDD"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TDD</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/22/PowerShell%E5%9F%BA%E7%A1%80/" title="PowerShell基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-22</div><div class="title">PowerShell基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/02/24/zT4VKe6ECMLfghY.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">MaQiang</div><div class="author-info__description">世事一场大梦，人生几度秋凉。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MakimaSasha"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MakimaSasha" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:imsupermq@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">下一步计划：Voron2.4 3D打印机</div></div><div class="card-widget"><div class="item-headline"><i></i><span></span></div><div class="item-content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基本概念_1——杂项篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#What-to-do-not-How-to-do"><span class="toc-number">1.0.1.</span> <span class="toc-text">What to do not How to do</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86%EF%BC%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">一些基本常识：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">编译过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#g-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">g++命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">基本概念_2——变量篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">常识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">2.0.2.</span> <span class="toc-text">重点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">基本概念_3——构造析构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-%E5%A6%82%EF%BC%9A"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">例子 如：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-%E5%A6%82%EF%BC%9A-1"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">例子 如：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-4%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96-amp-amp-new%E5%92%8Cdelete"><span class="toc-number">4.</span> <span class="toc-text">基础概念_4——对象初始化 &amp;&amp; new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">常识：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.2.</span> <span class="toc-text">默认构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E4%B8%8Edelete"><span class="toc-number">4.1.</span> <span class="toc-text">new与delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">实现流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">拓展：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">4.1.3.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5%E2%80%94%E2%80%94%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-amp-amp-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%EF%BC%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A6%96%E9%80%89%EF%BC%8C%E4%B8%94%E7%88%B6%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AA%E8%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%EF%BC%8C%E5%90%A6%E5%88%99%E7%88%B6%E7%B1%BB%E5%BE%97%E6%9C%89%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">基础概念_5——访问控制&amp;&amp;初始化列表（成员变量初始化首选，且父类的初始化只能初始化列表，否则父类得有默认构造函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#friend%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">friend的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F"><span class="toc-number">5.2.</span> <span class="toc-text">特别注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-6%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%BD%AF%E4%BB%B6%E9%87%8D%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">基础概念_6——组合，继承，软件重用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88-composition"><span class="toc-number">6.1.</span> <span class="toc-text">类的组合  composition</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">6.1.1.</span> <span class="toc-text">例子：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF-inheritance"><span class="toc-number">6.2.</span> <span class="toc-text">类的继承 inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.4.</span> <span class="toc-text">子类父类构造和析构的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E9%9A%90%E8%97%8F%EF%BC%88C-%E7%8B%AC%E6%9C%89%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">名字隐藏（C++独有）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-7%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-amp-amp-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">基础概念_7——函数重载 &amp;&amp;内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">7.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">特别注意：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-1"><span class="toc-number">7.3.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">7.4.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%EF%BC%9A-1"><span class="toc-number">7.5.</span> <span class="toc-text">特别注意：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">类中的内联函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-8%E2%80%94%E2%80%94const"><span class="toc-number">8.</span> <span class="toc-text">基础概念_8——const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">8.1.</span> <span class="toc-text">指针和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E6%80%BB%E7%BB%93-x3D-x3D"><span class="toc-number">8.2.</span> <span class="toc-text">&#x3D;&#x3D;总结&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">8.3.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8const%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">使用const来实现重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-1"><span class="toc-number">8.5.</span> <span class="toc-text">特别注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-9%E2%80%94%E2%80%94%E5%BC%95%E7%94%A8reference"><span class="toc-number">9.</span> <span class="toc-text">基础概念_9——引用	reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-2"><span class="toc-number">9.2.</span> <span class="toc-text">特别注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-10%E2%80%94%E2%80%94%E8%BD%AC%E6%8D%A2-conversion%EF%BC%8C%E9%80%A0%E5%9E%8B-amp-amp-%E5%A4%9A%E6%80%81%E6%80%A7-amp-amp-%E8%A6%86%E5%86%99-overriding"><span class="toc-number">10.</span> <span class="toc-text">基础概念_10——转换 conversion，造型 &amp;&amp; 多态性  &amp;&amp; 覆写 overriding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2-amp-amp-%E9%80%A0%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">转换&amp;&amp;造型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-polymorphism"><span class="toc-number">10.2.</span> <span class="toc-text">多态  polymorphism</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">10.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-x3D-x3D"><span class="toc-number">10.4.</span> <span class="toc-text">&#x3D;&#x3D;特别注意&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E5%86%99"><span class="toc-number">10.5.</span> <span class="toc-text">覆写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-11%E2%80%94%E2%80%94%E5%BC%95%E7%94%A8%E5%86%8D%E4%BD%93%E9%AA%8C"><span class="toc-number">11.</span> <span class="toc-text">基础概念_11——引用再体验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-x3D-x3D-1"><span class="toc-number">11.1.</span> <span class="toc-text">&#x3D;&#x3D;特别注意&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">11.2.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-12%E2%80%94%E2%80%94%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-number">12.</span> <span class="toc-text">基础概念_12——拷贝构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-x3D-x3D-2"><span class="toc-number">12.1.</span> <span class="toc-text">&#x3D;&#x3D;特别注意&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-13%E2%80%94%E2%80%94%E9%9D%99%E6%80%81-Static"><span class="toc-number">13.</span> <span class="toc-text">基础概念_13——静态 Static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%98%AF%E6%8A%8A%E9%82%A3%E4%B8%AA%E5%8F%98%E9%87%8F%E6%90%9E%E6%88%90%E4%BA%86%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B8%94%E5%A3%B0%E6%98%8E%E5%85%B6%E6%98%AF%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">static 成员变量（实际上就是把那个变量搞成了全局变量，且声明其是某个类的全局变量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">static成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-13%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">14.</span> <span class="toc-text">基础概念_13——运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-x3D-x3D-3"><span class="toc-number">14.2.</span> <span class="toc-text">&#x3D;&#x3D;特别注意&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8E%9F%E5%9E%8B"><span class="toc-number">14.3.</span> <span class="toc-text">常见的运算符原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E6%B7%AB%E5%B7%A7%E8%AE%A1"><span class="toc-number">14.4.</span> <span class="toc-text">奇淫巧计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.5.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.6.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-14%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94Template"><span class="toc-number">15.</span> <span class="toc-text">基础概念_14——模板——Template</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">15.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94function-template"><span class="toc-number">15.2.</span> <span class="toc-text">1.函数模板——function template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94class-tmeplate"><span class="toc-number">15.3.</span> <span class="toc-text">2_类模板——class tmeplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94template-function"><span class="toc-number">15.4.</span> <span class="toc-text">3_模板函数——template function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E2%80%94%E2%80%94template-class"><span class="toc-number">15.5.</span> <span class="toc-text">4_模板类——template class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-1-x3D-x3D"><span class="toc-number">15.6.</span> <span class="toc-text">&#x3D;&#x3D;特别注意_1&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-2-x3D-x3D"><span class="toc-number">15.7.</span> <span class="toc-text">&#x3D;&#x3D;特别注意_2&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-15%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E2%80%94%E2%80%94exception"><span class="toc-number">16.</span> <span class="toc-text">基础概念_15——异常——exception</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">16.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F-x3D-x3D-4"><span class="toc-number">16.2.</span> <span class="toc-text">&#x3D;&#x3D;特别注意&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-16%E2%80%94%E2%80%94%E6%B5%81%E2%80%94%E2%80%94stream"><span class="toc-number">17.</span> <span class="toc-text">基础概念_16——流——stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">17.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E8%87%AA%E5%AE%9A%E4%B9%89Manipulator-%E4%B8%8E-IOS-flag-x3D-x3D"><span class="toc-number">17.2.</span> <span class="toc-text">&#x3D;&#x3D;自定义Manipulator 与 IOS flag&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-17%E2%80%94%E2%80%94STL%E2%80%94%E2%80%94Standard-Library"><span class="toc-number">18.</span> <span class="toc-text">基础概念_17——STL——Standard Library</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB-%E4%BE%8B%E5%AD%90"><span class="toc-number">19.</span> <span class="toc-text">类_例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%AE%E7%A5%A8%E6%9C%BA%E7%B1%BB"><span class="toc-number">19.0.1.</span> <span class="toc-text">售票机类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">20.</span> <span class="toc-text">检验代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%B1%BB%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%80%BC-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-1-x3D-x3D"><span class="toc-number">20.0.1.</span> <span class="toc-text">分析类不同实例的成员变量值			&#x3D;&#x3D;检验代码_1&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">20.1.</span> <span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A2%E7%A9%B6c-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E8%B4%A8-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-2-x3D-x3D"><span class="toc-number">20.1.1.</span> <span class="toc-text">探究c++对象实质			&#x3D;&#x3D;检验代码_2&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-number">20.2.</span> <span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86new%E4%B8%8Edelete%E6%B5%8B%E8%AF%951%E4%B8%8D%E5%B8%A6-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-3-x3D-x3D"><span class="toc-number">20.2.1.</span> <span class="toc-text">解密new与delete	测试1	不带[]		&#x3D;&#x3D;检验代码_3&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-2"><span class="toc-number">20.3.</span> <span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86new%E4%B8%8Edelete%E6%B5%8B%E8%AF%952%E5%B8%A6-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-4-x3D-x3D"><span class="toc-number">20.3.1.</span> <span class="toc-text">解密new与delete	测试2	带[]	&#x3D;&#x3D;检验代码_4&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-3"><span class="toc-number">20.3.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86new%E4%B8%8Edelete-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-5-x3D-x3D"><span class="toc-number">20.3.3.</span> <span class="toc-text">解密new与delete				&#x3D;&#x3D;检验代码_5&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-4"><span class="toc-number">20.3.4.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%88%9D%E4%BD%93%E9%AA%8C-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-6-x3D-x3D"><span class="toc-number">20.3.5.</span> <span class="toc-text">继承初体验				&#x3D;&#x3D;检验代码_6&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-5"><span class="toc-number">20.3.6.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%86%8D%E4%BD%93%E9%AA%8C-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-7-x3D-x3D"><span class="toc-number">20.3.7.</span> <span class="toc-text">继承再体验				&#x3D;&#x3D;检验代码_7&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-6"><span class="toc-number">20.3.8.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%90%8D%E5%AD%97%E9%9A%90%E8%97%8F-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-8-x3D-x3D"><span class="toc-number">20.3.9.</span> <span class="toc-text">c++名字隐藏				&#x3D;&#x3D;检验代码_8&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-7"><span class="toc-number">20.4.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%87%8D%E8%BD%BD-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-9-x3D-x3D"><span class="toc-number">20.5.</span> <span class="toc-text">C++重载				&#x3D;&#x3D;检验代码_9&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-8"><span class="toc-number">20.6.</span> <span class="toc-text">输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BC%BA%E7%9C%81%E5%A3%B0%E6%98%8E%E6%8E%A2%E7%A9%B6-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-10-x3D-x3D"><span class="toc-number">20.6.1.</span> <span class="toc-text">C++缺省声明探究				&#x3D;&#x3D;检验代码_10&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-9"><span class="toc-number">20.6.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E8%B0%83%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-11-x3D-x3D"><span class="toc-number">20.6.3.</span> <span class="toc-text">C++其他编译单元调用内联函数				&#x3D;&#x3D;检验代码_11&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-10"><span class="toc-number">20.6.4.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-const%E8%BF%90%E7%94%A8-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-12-x3D-x3D"><span class="toc-number">20.6.5.</span> <span class="toc-text">C++ const运用				&#x3D;&#x3D;检验代码_12&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-11"><span class="toc-number">20.6.6.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-const%E8%BF%90%E7%94%A8-2-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-13-x3D-x3D"><span class="toc-number">20.6.7.</span> <span class="toc-text">C++ const运用_2				&#x3D;&#x3D;检验代码_13&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-12"><span class="toc-number">20.6.8.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-conversion-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-14-x3D-x3D"><span class="toc-number">20.6.9.</span> <span class="toc-text">C++ conversion				&#x3D;&#x3D;检验代码_14&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-13"><span class="toc-number">20.6.10.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-virtual%E5%85%B3%E9%94%AE%E5%AD%97-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-15-x3D-x3D"><span class="toc-number">20.6.11.</span> <span class="toc-text">C++ virtual关键字				&#x3D;&#x3D;检验代码_15&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-14"><span class="toc-number">20.6.12.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E9%AD%94%E6%94%B9vtpr-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-16-x3D-x3D"><span class="toc-number">20.6.13.</span> <span class="toc-text">C++ 魔改vtpr				&#x3D;&#x3D;检验代码_16&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-15"><span class="toc-number">20.6.14.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%A6%86%E5%86%99-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-17-x3D-x3D"><span class="toc-number">20.6.15.</span> <span class="toc-text">C++ 覆写				&#x3D;&#x3D;检验代码_17&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-16"><span class="toc-number">20.6.16.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%BC%95%E7%94%A8%E5%86%8D%E4%BD%93%E9%AA%8C-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-18-x3D-x3D"><span class="toc-number">20.6.17.</span> <span class="toc-text">C++ 引用再体验				&#x3D;&#x3D;检验代码_18&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-17"><span class="toc-number">20.6.18.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-19-x3D-x3D"><span class="toc-number">20.6.19.</span> <span class="toc-text">C++ 匿名变量				&#x3D;&#x3D;检验代码_19&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-18"><span class="toc-number">20.6.20.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-20-x3D-x3D"><span class="toc-number">20.6.21.</span> <span class="toc-text">C++ 静态成员变量				&#x3D;&#x3D;检验代码_20&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-19"><span class="toc-number">20.6.22.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-x3D-x3D-%E6%A3%80%E9%AA%8C%E4%BB%A3%E7%A0%81-21-x3D-x3D"><span class="toc-number">20.6.23.</span> <span class="toc-text">C++ 自动类型转换				&#x3D;&#x3D;检验代码_21&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-20"><span class="toc-number">20.6.24.</span> <span class="toc-text">输出</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/24/Git%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/" title="Git笔记">Git笔记</a><time datetime="2022-05-24T15:12:10.000Z" title="发表于 2022-05-24 23:12:10">2022-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/22/PowerShell%E5%9F%BA%E7%A1%80/" title="PowerShell基础">PowerShell基础</a><time datetime="2022-05-22T11:53:26.000Z" title="发表于 2022-05-22 19:53:26">2022-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="VSCode环境配置">VSCode环境配置</a><time datetime="2022-05-12T01:21:45.000Z" title="发表于 2022-05-12 09:21:45">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/24/C++%E5%9F%BA%E7%A1%80/" title="C++ 面向对象">C++ 面向对象</a><time datetime="2022-04-24T02:29:36.000Z" title="发表于 2022-04-24 10:29:36">2022-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/24/TDD/" title="TDD">TDD</a><time datetime="2022-03-24T13:30:25.000Z" title="发表于 2022-03-24 21:30:25">2022-03-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By MaQiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>